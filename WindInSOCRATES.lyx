#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\input colordvi
\usepackage{color}
%\fancyhead{}
%\fancyfoot[CE,CO]{}
\newtoks{\topicofnote} \global\topicofnote={}
\newdimen\longindent \longindent=3.5truein
%\fancyhead[L]{Aircraft Algorithm Memo re: \the\topicofnote \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lyxlst}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\RAFAlgorithmMemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Research Aviation Facility}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Algorithm Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.2truein\leftline{\textcolor{blue}{\textsf{Subject: \the\topicofnote}}}
\leftline{\textcolor{blue}{\textsf{Al Cooper}}}
\leftline{\textcolor{blue}{\textsf{\datetoday}}} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lyxlst}{Attachments:00}
\item [Attachments:] {#1}
\end{lyxlst}}
\newcommand{\cc}[1]{\begin{lyxlst}{Attachments:00}
\item [cc:] {#1}
\end{lyxlst}}
\newcommand{\attach}[1]{\begin{lyxlst}{Attachments:00}
\item [Attachment:] {#1}
\end{lyxlst}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.2in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\headheight 1cm
\headsep 2cm
\footskip 0.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Wind Measurements in SOCRATES
\end_layout

\begin_layout Author
Al Cooper
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
datetoday
\end_layout

\end_inset


\end_layout

\begin_layout Address
National Center for Atmospheric Research
\begin_inset Newline newline
\end_inset

Earth Observing Laboratory
\begin_inset Newline newline
\end_inset

Research Aviation Facility
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\begin_inset Newpage cleardoublepage
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
contentsname}{Table of Contents} 
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset

 
\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
eject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
abstractname}{Abstract}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The gust pod consists of a Rosemount 858 probe installed in an underwing
 instrument canister along with a small CMIGITS inertial unit.
 It is described at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/instruments/all-weather-wind-gust-pod"

\end_inset

.
 The probe is heated to prevent icing and therefore often produces measurements
 in extreme conditions when the standard radome system can becomed blocked
 by icing or frozen lines, so it is a useful backup system.
 In addition, because the five holes in the probe are located close together
 and are connected to pressure transducers by short lines, the instrument
 has the ability to measure high-frequency fluctuations in the wind and
 therefore is a useful complement to the standard wind-sensing system.
 However, the location of the probe below the wing leads to serious distortions
 in the airflow before it reaches the sensor, and these must be considered
 when wind measurements are made.
 The purpose of this note is to document a calculation that addresses this
 problem and that produces wind measurements of quality comparable to those
 from the standard radome-based system.
 In addition, some variance spectra from the gust pod are shown to demonstrate
 its ability to measure fluctuations in the frequency range from 1â€“10 Hz.
 A second-pass processor is developed and documented that can add the appropriat
e wind variables to an existing netCDF data file.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This documents discusses some of the options for measuring wind in SOCRATES.
 The NSF/NCAR GV has some new capabilities that might improve the measurements
 of wind, but they are not fully investigated and documented yet and in
 some cases the processing algorithms have not be developed.
 This report documents some studies of the new measurements and recommends
 new procedures and processing algorithms for the calculation of wind.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
set topicofnote to topic of note
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
topicofnote={Gust-Pod Processing for Socrates}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
RAFAlgorithmMemo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
General scope of this report
\end_layout

\begin_layout Standard
The NCAR Technical Note on 
\begin_inset Quotes eld
\end_inset

Characterization of Uncertainty in Measurements of Wind from the NSF/NCAR
 GV
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

) includes an extensive discussion of the wind-measuring capabilities of
 the GV, and a journal article (
\begin_inset CommandInset citation
LatexCommand citet
key "CooperEtAl2014"

\end_inset

) documented how a laser air-motion sensor can be used to improve those
 measurements.
 In addition, a recent technical note (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2017ncartn"

\end_inset

) presented an approach to improving the measurements through use of a Kalman
 filter.
 Despite this work, one aspect has remained troublesome: The variance spectra
 of the measurements, especially of the longitudinal component of the wind,
 show unacceptable noise.
 This is documented in the 2016 NCAR Technical Note referenced above, in
 an appendix that discusses the high-frequency measurements and indicates,
 after a suggestion by Don Lenschow, that the problem is resonance noise
 in the long lines used to connect pressure sensors to the relevant ports.
\end_layout

\begin_layout Standard
Since then, RAF has installed a new pitot-static sensor for the measurement
 of the airspeed.
 That instrument uses much shorter lines, so it is hoped that it will reduce
 the noise.
 In addition, the gust pod is being flown in SOCRATES as another candidate
 for making high-frequency measurements, because its lines are still shorter
 and the sensing probe itself in only a few inches across so may provide
 the best high-frequency measurements.
 Although the sensor was used before in the DEEPWAVE project and provided
 good measurements, as documented in the 2016 technical note, it is flown
 in a new configuration in SOCRATES that includes the large pods under the
 wings.
 These were not present in DEEPWAVE and apparently change the distortion
 of airflow approaching the gust pod, and the processing developed for DEEPWAVE
 does not work in SOCRATES.
\end_layout

\begin_layout Standard
One additional source of information about the wind-sensing system is the
 ARISTO-2017 experiment, in which the Laser Air-Motion Sensor (LAMS) was
 flown.
 This provides an opportunity to check and possibly update the airspeed
 calibration reported in the 2014 paper.
 The large pods were present in ARISTO-2017 also, so if there is any effect
 on the standard system it should be possible to detect it by using these
 new measurements.
\end_layout

\begin_layout Standard
This report is organized into the following main sections:
\end_layout

\begin_layout Itemize
Section 2 discusses the ARISTO-2017 flights and the use of LAMS to check
 the measurement of airspeed.
 
\end_layout

\begin_layout Itemize
Section 2 discusses the new pitot-static sensor and proposes a way to use
 its measurement for the calculation of wind.
 
\end_layout

\begin_layout Itemize
Section 4 develops a new approach to processing the data from the gust pod
 and shows results from that instrument.
\end_layout

\begin_layout Standard
The conclusions then discuss proposed ways to process the data.
 The proposed processing has been incorporated into the 
\begin_inset Quotes eld
\end_inset

QAtools
\begin_inset Quotes erd
\end_inset

 shiny app that is available in the field, so these variables can be added
 to netCDF files produced there to see the effect of these new measurements.
 Some of what is proposed can be incorporated into standard processing (in
 
\begin_inset Quotes eld
\end_inset

nimbus
\begin_inset Quotes erd
\end_inset

), but other parts may require second-pass processing to add the relevant
 variables.
\end_layout

\begin_layout Standard
The text document and the data processing are incorporated into a single
 file, named 
\begin_inset Quotes eld
\end_inset

WindInSOCRATES.Rnw
\begin_inset Quotes erd
\end_inset

, located in the EOL directory ~cooperw/RStudio/Reprocessing/ .
 A 
\begin_inset Quotes eld
\end_inset

Reproducibility
\begin_inset Quotes erd
\end_inset

 Appendix discusses how this work could be duplicated, and all the needed
 components are archived in a GitHub directory, as discussed in that Appendix.
\end_layout

\begin_layout Subsection
Comments related to the standard radome-based system
\end_layout

\begin_layout Standard
The approach to the gust-pod will be to match the results from the radome
 system, so that system is revisited here first.
 A script produced earlier for ORCAS, AKRD.Rnw, implemented second-pass processin
g for AKRD using a complementary-filter approach and developed appropriate
 coefficients and formulas.
 Because implementation of that approach is still pending, some of the informati
on is repeated here.
 In addition, data from early SOCRATES flights are added to the dataset
 used previously to test that the results are appropriate for SOCRATES.
 (It will be useful to repeat this analysis with additional SOCRATES flights
 when they become available.)
\end_layout

\begin_layout Standard
For reference, the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 representation in use for several years has been
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha=c_{0}+\frac{\Delta p_{\alpha}}{q}\left(c_{1}+c_{2}M\right)
\]

\end_inset

and the coefficients were found by fitting that formula to a reference that
 assumes there is zero vertical wind:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\alpha^{*}=\theta-\frac{w_{p}}{V}
\]

\end_inset


\end_layout

\begin_layout Standard
The justification for this form is that studies of five-hole pressure sensors
 have found a Mach-number dependence that affects their sensitivity.
 
\end_layout

\begin_layout Standard
Here the approach will be different.
 The reference value is split into two components, 
\begin_inset Formula $\alpha^{*}=\alpha_{f}^{*}+\alpha_{s}^{*}$
\end_inset

 that result from applying a Butterworth low-pass filter to 
\begin_inset Formula $\alpha^{*}$
\end_inset

 (in the code, the variable AOAREF) to obtain 
\begin_inset Formula $\alpha_{s}^{*}$
\end_inset

 and then finding 
\begin_inset Formula $\alpha_{f}^{*}$
\end_inset

from 
\begin_inset Formula $\alpha_{f}^{*}=\alpha^{*}-\alpha_{s}^{*}$
\end_inset

.
 These components are then represented by separate fits:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\alpha_{f}=\left(\frac{\mathrm{\{ADIFR\}}}{\mathrm{\{QCF\}}}\right)_{f}(c_{1}+c_{2}M)\label{eq:alpha-fast}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\alpha_{s}=d_{0}+d_{1}\left(\frac{\mathrm{\{ADIFR\}}}{\mathrm{\{QCF\}}}\right)_{s}+d_{2}\mathrm{\{QCF\}}_{s}\label{eq:alpha-slow}
\end{equation}

\end_inset

where the 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 subscripts represent the high-pass and low-pass components after filtering.
 More complicated representations were tested in both cases, but these appear
 to provide adequate fits without additional terms.
 The 
\begin_inset Formula $c_{2}$
\end_inset

 term representing Mach-number dependence does not appear to be necessary,
 but the expectation that there will be some dependence on 
\begin_inset Formula $M$
\end_inset

 justified its tentative inclusion.
 However, the fits below show no significant difference with 
\begin_inset Formula $c_{2}=0$
\end_inset

, and an analysis of variance made its inclusion appear questionable, so
 it has been dropped from the calculations presented here.
\end_layout

\begin_layout Standard
This approach has two advantages:
\end_layout

\begin_layout Enumerate
The important sensitivity to fluctuations is not compromised by efforts
 to represent the slowly varying zero level for angle of attack.
\end_layout

\begin_layout Enumerate
The slowly varying zero reference can be represented by more complex equations
 without needing to apply those to the high-frequency component.
\end_layout

\begin_layout Standard
The result is an empirical representation that is appropriate for all recent
 GV projects and that does not need to be changed for each project, as has
 been the case for many recent projects that use the standard representation.
 
\end_layout

\begin_layout Subsubsection
Data used in the fit
\end_layout

\begin_layout Standard
The selection of data was described in the previous memo, but that information
 will be repeated here with the addition of SOCRATES data.
 The first step is to assemble the data to be used for fitting.
 The data set should include as many flights and projects as is reasonable,
 but should be reviewed also to eliminate flights that appear anomalous
 because of problems with the measurements, strong updrafts and downdrafts,
 special loading conditions, or other aspects of the flights that make them
 questionable to include.
\end_layout

\begin_layout Standard
In this case, measurements from ORCAS, CSET, DEEPWAVE and early SOCRATES
 were used.
 For CSET, the selected flights were 1, 2, 3, 4, 6, 10, 12, and 16.
 For ORCAS, flights 1, 2, 3, 6, 8, 9, 11, 14, and 16 were selected.
 For DEEPWAVE, all 26 flights were used excepting 6, 7, 15, and 23.
 For SOCRATES, test flight 1 is particularly useful to include because it
 includes the only maneuvers to data.
 Research flights 1 and 2 are the only ones available to data and are needed
 to emphasize the low-level flight segments that are important conditions
 for the measurement of wind, but for now they have been excluded because
 the vertical-wind variance spectra suggest some problem with ADIFR\SpecialChar endofsentence
 To use
 different flights in the future, changes to the 'Project' statements and
 'best' statements will be needed, and in addition it will be necessary
 to change the logical variables 'NewCoefficients' and 'ReloadData' to TRUE.
 Otherwise, this program skips recalculation of the coefficients and just
 retrieves them from the file './AKRD-fit-coef.Rdata' where they have been
 stored by a previous run.
 The process of constructing the data.frame used in the fit, not necessary
 if those previously determined coefficients are to be used, was as follows:
\end_layout

\begin_layout Enumerate
Read the netCDF file as on /scr/raf_data/{Project}, for each flight in CSET
 and ORCAS (not just the ones listed above).
\begin_inset Foot
status open

\begin_layout Plain Layout
For ORCAS flight 12, the available netCDF file was bad and couldn't be read,
 so that flight was skipped.
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
For each file, add appropriate variables for fitting (QR=ADIFR/QCF, M=Mach
 number using uncorrected pressures, AOAREF=PITCH-(GGVSPD/TASF)*180/
\begin_inset Formula $\pi$
\end_inset

, QCF) and the low-pass and high-pass components of these produced by a
 Butterworth third-order filter with cutoff frequency of 1/600 Hz.
 A version of the filter was used that made two passes, one forward and
 one backward, through the data and combined the results.
 Some exploration of values for the cutoff frequency led to similar results
 over a wide range from 0.01
\begin_inset space ~
\end_inset

Hz to 0.001
\begin_inset space ~
\end_inset

Hz, but the choice (1/600)
\begin_inset space ~
\end_inset

Hz appeared to be a good compromise between the conflicting requirements
 to represent the low-pass component well without having it distort the
 high-pass response.
\end_layout

\begin_layout Enumerate
The file was truncated to include only data spanning from the first measurement
 of airspeed above 90
\begin_inset space ~
\end_inset

m/s to the last, to avoid periods when the aircraft was still on the ground
 or just after take-off.
\end_layout

\begin_layout Enumerate
A variable representing flight number was added to each file.
 To avoid ambiguity between projects, ORCAS flights were assigned numbers
 equal to 100 plus the flight number.
 This variable, named RF, then made it possible to identify individual flights
 after all were concatenated.
\end_layout

\begin_layout Enumerate
The individual flights were then concatenated into one data.frame containing
 only the variables needed for fitting and a few others used while examining
 the results.
 The variables in the data.frame were ADIFR, AKRD, GGALT, GGVSPD, PITCH,
 PSF, QCF, ROLL, SSLIP, TASF, TASX, THDG, WIC, and those added in step 2
 above.
\end_layout

\begin_layout Enumerate
From this data frame, another (called DF) was constructed to use in fitting.
 It consisted only of the 17 selected flights listed above.
 In addition, measurements spanning 600
\begin_inset space ~
\end_inset

s from the start and end of each file were removed to avoid periods where
 end-effects seemed to cause problems with the filtered results and also
 to avoid problematic periods during initial climb and final descent, which
 otherwise seemed to distort the fits.
\end_layout

\begin_layout Enumerate
The final data.frame (DF) was then restricted to measurements with TASF >
 110 and ROLL between -2 and 2
\begin_inset Formula $^{\circ}$
\end_inset

, to avoid possible periods of slow flight or in turns.
 Turns in particular invalidate the fit assumption involved in finding the
 reference (AOAREF) used for the fit, so these need to be excluded or turns
 cause serious distortion of the results.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

require(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.path='figure/SO-', echo=FALSE, include=FALSE, fig.lp="fig:",
 dev='png', dpi=100, fig.show='hold', size='footnotesize', replace.assign=TRUE,
 width=49)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
\end_layout

\begin_layout Plain Layout

options(digits=5)
\end_layout

\begin_layout Plain Layout

thisFileName <- "AKRDforSOCRATES"
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(ggplot2)
\end_layout

\begin_layout Plain Layout

require(grid)
\end_layout

\begin_layout Plain Layout

require(ggthemes)
\end_layout

\begin_layout Plain Layout

require(zoo)
\end_layout

\begin_layout Plain Layout

ReviseProjects <- c('SOCRATES')  ## these are the projects to process 
\end_layout

\begin_layout Plain Layout

nP <- length (ReviseProjects)
\end_layout

\begin_layout Plain Layout

# ReviseProjects <- 'ORCAS'
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()			
\end_layout

\begin_layout Plain Layout

VarList <- c("ADIFR", "GGVSPD", "PITCH", "QCF", "PSF", "AKRD", "WIC", "TASF",
 "GGALT", "ROLL", "PSXC", "ATX", "QCXC")
\end_layout

\begin_layout Plain Layout

## add variables needed to recalculate wind
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, "TASX", "ATTACK", "SSLIP", "GGVEW", "GGVNS", "VEW",
 "VNS", "THDG")
\end_layout

\begin_layout Plain Layout

SaveRData <- sprintf("%s.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

## this controls if new coefficients are calculated and associated plots
 made:
\end_layout

\begin_layout Plain Layout

NewCoefficients <- FALSE
\end_layout

\begin_layout Plain Layout

# NewCoefficients <- TRUE
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SummarizeFit <- function(ft) {
\end_layout

\begin_layout Plain Layout

  print (summary(ft)$call)
\end_layout

\begin_layout Plain Layout

  print ("Coefficients:")
\end_layout

\begin_layout Plain Layout

  print (summary(ft)$coefficients)
\end_layout

\begin_layout Plain Layout

  print (sprintf ("Residual standard error: %.3f, dof=%d", summary(ft)$sigma,
 summary(ft)$df[2]))
\end_layout

\begin_layout Plain Layout

  print (sprintf ("R-squared %.3f", summary(ft)$r.squared))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<construct-dataframe, eval=NewCoefficients>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ReloadData <- FALSE  ## have old data for CSET, ORCAS, DEEPWAVE;
\end_layout

\begin_layout Plain Layout

                     ## need new for SOCRATES
\end_layout

\begin_layout Plain Layout

# ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

Project <- "ORCAS"
\end_layout

\begin_layout Plain Layout

Data <- data.frame()
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  for (flt in 1:19) {
\end_layout

\begin_layout Plain Layout

    if (flt == 12) {next}  ## file is bad
\end_layout

\begin_layout Plain Layout

    fname = sprintf("%s%s/%srf%02d.nc", DataDirectory(),Project,Project,flt)
\end_layout

\begin_layout Plain Layout

    fno <- flt
\end_layout

\begin_layout Plain Layout

    D <- getNetCDF (fname, VarList, F=fno)
\end_layout

\begin_layout Plain Layout

    D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$AOAREF <- (D$PITCH - (D$GGVSPD / D$TASF) * (180 / pi)) 
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- 1
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- zoo::na.approx (as.vector(D$AOAREF), maxgap=1000*Rate, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

    D$AOAREFS[is.na(D$AOAREFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$AOAREFS
)
\end_layout

\begin_layout Plain Layout

    D$AOAREFF <-  D$AOAREF - D$AOAREFS
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

    ## limit to times between first TASX > 90 and last TASX > 90:
\end_layout

\begin_layout Plain Layout

    TS <- D$Time[D$TASX > 90]
\end_layout

\begin_layout Plain Layout

    TS <- TS[!is.na(TS)]
\end_layout

\begin_layout Plain Layout

    B <- TS[1]; E <- TS[length(TS)]
\end_layout

\begin_layout Plain Layout

    D <- D[D$Time >= B & D$Time <= E,]
\end_layout

\begin_layout Plain Layout

    Data <- rbind (Data, D)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  save(Data, file='AKRDforORCAS.Rdata')
\end_layout

\begin_layout Plain Layout

  Data$RF <- Data$RF + 100
\end_layout

\begin_layout Plain Layout

  Data1 <- Data
\end_layout

\begin_layout Plain Layout

  Data <- data.frame()
\end_layout

\begin_layout Plain Layout

  Project <- 'CSET'
\end_layout

\begin_layout Plain Layout

  for (flt in 1:16) {
\end_layout

\begin_layout Plain Layout

    fname = sprintf("%s%s/%srf%02d.nc", DataDirectory(),Project,Project,flt)
\end_layout

\begin_layout Plain Layout

    fno <- flt
\end_layout

\begin_layout Plain Layout

    D <- getNetCDF (fname, VarList, F=fno)
\end_layout

\begin_layout Plain Layout

    D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$AOAREF <- (D$PITCH - (D$GGVSPD / D$TASF) * (180 / pi)) 
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- 1
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- zoo::na.approx (as.vector(D$AOAREF), maxgap=1000*Rate, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

    D$AOAREFS[is.na(D$AOAREFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$AOAREFS
)
\end_layout

\begin_layout Plain Layout

    D$AOAREFF <-  D$AOAREF - D$AOAREFS
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

    ## limit to times between first TASX > 90 and last TASX > 90:
\end_layout

\begin_layout Plain Layout

    TS <- D$Time[D$TASX > 90]
\end_layout

\begin_layout Plain Layout

    TS <- TS[!is.na(TS)]
\end_layout

\begin_layout Plain Layout

    B <- TS[1]; E <- TS[length(TS)]
\end_layout

\begin_layout Plain Layout

    D <- D[D$Time >= B & D$Time <= E,]
\end_layout

\begin_layout Plain Layout

    Data <- rbind (Data, D)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  save(Data, file='AKRDforCSET.Rdata')
\end_layout

\begin_layout Plain Layout

  Data1 <- rbind (Data1, Data)
\end_layout

\begin_layout Plain Layout

  Data <- data.frame()
\end_layout

\begin_layout Plain Layout

  Project <- 'DEEPWAVE'
\end_layout

\begin_layout Plain Layout

  for (flt in 1:26) {
\end_layout

\begin_layout Plain Layout

    fname = sprintf("%s%s/%srf%02d.nc", DataDirectory(),Project,Project,flt)
\end_layout

\begin_layout Plain Layout

    fno <- flt
\end_layout

\begin_layout Plain Layout

    D <- getNetCDF (fname, VarList, F=fno)
\end_layout

\begin_layout Plain Layout

    D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$AOAREF <- (D$PITCH - (D$GGVSPD / D$TASF) * (180 / pi)) 
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- 1
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- zoo::na.approx (as.vector(D$AOAREF), maxgap=1000*Rate, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

    D$AOAREFS[is.na(D$AOAREFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$AOAREFS
)
\end_layout

\begin_layout Plain Layout

    D$AOAREFF <-  D$AOAREF - D$AOAREFS
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

    ## limit to times between first TASX > 90 and last TASX > 90:
\end_layout

\begin_layout Plain Layout

    TS <- D$Time[D$TASX > 90]
\end_layout

\begin_layout Plain Layout

    TS <- TS[!is.na(TS)]
\end_layout

\begin_layout Plain Layout

    B <- TS[1]; E <- TS[length(TS)]
\end_layout

\begin_layout Plain Layout

    D <- D[D$Time >= B & D$Time <= E,]
\end_layout

\begin_layout Plain Layout

    Data <- rbind (Data, D)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  save(Data, file='AKRDforDEEPWAVE.Rdata')
\end_layout

\begin_layout Plain Layout

  Data$RF <- Data$RF + 200
\end_layout

\begin_layout Plain Layout

  Data <- rbind (Data1, Data)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load(file='AKRDforORCAS.Rdata')
\end_layout

\begin_layout Plain Layout

  Data1 <- Data
\end_layout

\begin_layout Plain Layout

  Data1$RF <- Data1$RF + 100
\end_layout

\begin_layout Plain Layout

  load(file='AKRDforCSET.Rdata')
\end_layout

\begin_layout Plain Layout

  Data <- rbind (Data, Data1)
\end_layout

\begin_layout Plain Layout

  Data1 <- Data
\end_layout

\begin_layout Plain Layout

  load(file='AKRDforDEEPWAVE.Rdata')
\end_layout

\begin_layout Plain Layout

  Data$RF <- Data$RF + 200
\end_layout

\begin_layout Plain Layout

  Data1 <- rbind (Data, Data1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## add SOCRATES flights:
\end_layout

\begin_layout Plain Layout

  Data <- data.frame()
\end_layout

\begin_layout Plain Layout

  Project <- 'SOCRATES'
\end_layout

\begin_layout Plain Layout

  for (flt in c(-1, -2, 1, 2)) {
\end_layout

\begin_layout Plain Layout

    if (flt < 0) {
\end_layout

\begin_layout Plain Layout

      fname = sprintf("%s%s/%stf%02d.nc", DataDirectory(),Project,Project,-flt)
\end_layout

\begin_layout Plain Layout

      fno <- 50 - flt
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      fname = sprintf("%s%s/%srf%02d.nc", DataDirectory(),Project,Project,flt)
\end_layout

\begin_layout Plain Layout

      fno <- flt
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    D <- getNetCDF (fname, VarList, F=fno)
\end_layout

\begin_layout Plain Layout

    D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$AOAREF <- (D$PITCH - (D$GGVSPD / D$TASF) * (180 / pi)) 
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- 1
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- zoo::na.approx (as.vector(D$AOAREF), maxgap=1000*Rate, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

    D$AOAREFS[is.na(D$AOAREFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$AOAREFS
)
\end_layout

\begin_layout Plain Layout

    D$AOAREFF <-  D$AOAREF - D$AOAREFS
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

    ## limit to times between first TASX > 60 and last TASX > 60:
\end_layout

\begin_layout Plain Layout

    TS <- D$Time[D$TASX > 60]
\end_layout

\begin_layout Plain Layout

    TS <- TS[!is.na(TS)]
\end_layout

\begin_layout Plain Layout

    B <- TS[1]; E <- TS[length(TS)]
\end_layout

\begin_layout Plain Layout

    D <- D[D$Time >= B & D$Time <= E,]
\end_layout

\begin_layout Plain Layout

    Data <- rbind (Data, D)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  save(Data, file='AKRDforSOCRATES.Rdata')
\end_layout

\begin_layout Plain Layout

  Data$RF <- Data$RF + 300
\end_layout

\begin_layout Plain Layout

  Data <- rbind (Data1, Data)
\end_layout

\begin_layout Plain Layout

  save(Data, file='AKRDdata.Rdata')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reloadIfNeeded, eval=!NewCoefficients>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

load('AKRDdata.Rdata')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<buildDF>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DF <- data.frame()
\end_layout

\begin_layout Plain Layout

best <- c(1,2,3,6,8,9,11,14,18)+100
\end_layout

\begin_layout Plain Layout

for (flt in best) {
\end_layout

\begin_layout Plain Layout

  if (flt == 112) {next}
\end_layout

\begin_layout Plain Layout

  D <- Data[Data$RF == flt, ]
\end_layout

\begin_layout Plain Layout

  D <- D[601:(nrow(D)-600), ]
\end_layout

\begin_layout Plain Layout

  DF <- rbind (DF, D)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

best <- c(1,2,3,4,6,10,12,16)
\end_layout

\begin_layout Plain Layout

for (flt in best) {
\end_layout

\begin_layout Plain Layout

  D <- Data[Data$RF == flt, ]
\end_layout

\begin_layout Plain Layout

  D <- D[601:(nrow(D)-600), ]
\end_layout

\begin_layout Plain Layout

  DF <- rbind (DF, D)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

best <- c(1,2,3,4,5,8,9,10,11,12,13,14,16,17,18,19,20,21,22,24,25,26) +
 200
\end_layout

\begin_layout Plain Layout

for (flt in best) {
\end_layout

\begin_layout Plain Layout

  if (flt == 112) {next}
\end_layout

\begin_layout Plain Layout

  D <- Data[Data$RF == flt, ]
\end_layout

\begin_layout Plain Layout

  D <- D[601:(nrow(D)-600), ]
\end_layout

\begin_layout Plain Layout

  DF <- rbind (DF, D)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

best <- c(51,52) + 300
\end_layout

\begin_layout Plain Layout

for (flt in best) {
\end_layout

\begin_layout Plain Layout

  D <- Data[Data$RF == flt, ]
\end_layout

\begin_layout Plain Layout

  D <- D[601:(nrow(D)-600), ]
\end_layout

\begin_layout Plain Layout

  DF <- rbind (DF, D)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

DF <- DF[DF$TASX > 110 & abs(DF$ROLL) < 2, ]
\end_layout

\begin_layout Plain Layout

## now have data.frame DF containing values for fitting
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fits-to-DF>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (NewCoefficients) {
\end_layout

\begin_layout Plain Layout

  f <- lm (AOAREF ~ QR + I(QR*M), data=DF)
\end_layout

\begin_layout Plain Layout

  cf <- coef(f)
\end_layout

\begin_layout Plain Layout

  ff <- lm (AOAREFF ~ 0 + QRF, data=DF)
\end_layout

\begin_layout Plain Layout

  cffn <- coef (ff)
\end_layout

\begin_layout Plain Layout

  cff <- 21.481   ## force DEEPWAVE value
\end_layout

\begin_layout Plain Layout

  fs <- lm(AOAREFS~QRS+QCFS, data=DF)
\end_layout

\begin_layout Plain Layout

  cfs <- coef(fs)
\end_layout

\begin_layout Plain Layout

  save (cffn, cff, cfs, ff, fs, file='AKRD-fit-coef.Rdata')
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file='AKRD-fit-coef.Rdata')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

  SummarizeFit <- function(ft) {
\end_layout

\begin_layout Plain Layout

    print (summary(ft)$call)
\end_layout

\begin_layout Plain Layout

    print ("Coefficients:")
\end_layout

\begin_layout Plain Layout

    print (summary(ft)$coefficients)
\end_layout

\begin_layout Plain Layout

    print (sprintf ("Residual standard deviation: %.3f, dof=%d", summary(ft)$sigm
a, summary(ft)$df[2]))
\end_layout

\begin_layout Plain Layout

    print (sprintf ("R-squared %.3f", summary(ft)$r.squared))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fit results
\end_layout

\begin_layout Standard
The result of fitting using (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-fast"

\end_inset

) was 
\begin_inset Formula $c_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cffn,4)}
\end_layout

\end_inset

, but an earlier fit to more selective speed-run and other data in DEEPWAVE
 suggested a value of 
\begin_inset Formula $c_{1}=21.481$
\end_inset

, as described in the NCAR Technical Note on Wind Uncertainty (
\begin_inset CommandInset citation
LatexCommand cite
key "Cooper2016ncartn"

\end_inset

).
 That appears to provide a good representation of the CSET/ORCAS/SOCRATES
 data as well, so that coefficient will be used here.
 For the low-pass component, the coefficients from the fit to (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-slow"

\end_inset

) were {
\begin_inset Formula $d$
\end_inset

} = {
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfs[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfs[2], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfs[3], 6)}
\end_layout

\end_inset

}, and the residual standard deviation for this fit was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fs)$sigma, 3)}
\end_layout

\end_inset

.
 These results are discussed further in a presentation that is available
 
\begin_inset CommandInset href
LatexCommand href
name "here"
target "https://drive.google.com/open?id=0B1kIUH45ca5ALXktNklmdkl3bFU"

\end_inset

, where the choice for 
\begin_inset Formula $c_{1}$
\end_inset

 is also explained.
\end_layout

\begin_layout Section
Measurements from LAMS in ARISTO-2017
\end_layout

\begin_layout Standard
The purpose of this section is to consider if the LAMS measurements from
 ARISTO2017 are consistent with the previous study of the PCOR function
 as presently documented in the Processing Algorithms Technical Note.
 During this GV project, the LAMS was flown in a 4-beam configuration.
 The beam assignments were non-standard, though, with beam 2 forward, beam
 1 downward, beam 3 outboard and upward, and beam 4 inboard and upward.
 Beams 1, 3 and 4 were approximately 35
\begin_inset Formula $^{\circ}$
\end_inset

 from the forward direction, and relative to an azimuthal angle starting
 from the downward direction they were, respectively, 0, 
\begin_inset Formula $-120$
\end_inset

 and 120
\begin_inset Formula $^{\circ}$
\end_inset

 in clockwise rotation about the forward longitudinal axis.
 
\end_layout

\begin_layout Standard
There were six research flights in ARISTO-2017, but the LAMS was not operational
 on the last two so those will not be used here.
 Research flight 4 was particularly useful because it extended to low level
 and so expanded the envelope of measurements that can constrain the pressure-co
rrection algorithms.
 However, LAMS was not operational before about 20:00:00 UTC on this flight.
 Although there were four beams, the fourth seldom produced useful measurements
 so it will be necessary to use the three-beam solution for the wind vector.
\end_layout

\begin_layout Standard
For ARISTO-2017, the line-of-sight beam speeds were determined in two ways.
 Matt Hayman improved upon the processing method originally used by Scott
 Spuler in the 2014 study.
 This usually worked very well.
 Because there was tight coupling to the expected measured TAS (with adjustment
 for the beam angles), it might be suspect that the method may be biased
 toward the TAS value at times that have a marginal signal.
 Therefore, a second method was to fit the background using Savitzgy-Golay
 polynomials and then search for peaks above this background, as was done
 in the original PCOR determination.
 When signals were strong, the method usually produced the same result as
 the PCA method, but it was more prone to failure during periods where the
 signal was weak.
 (A signal-to-noise test of 
\begin_inset Formula $\geq4$
\end_inset

 was required for a valid measurement.) Results from both these peak-detecting
 algorithms will be discussed in this memo.
 
\end_layout

\begin_layout Standard
There are several objectives that can be met by using the LAMS-derived measureme
nts:
\end_layout

\begin_layout Enumerate
The LAMS provides an independent measurement of angle-of-attack and sideslip
 angle, so these measurements can be used to check the empirical relationships
 used to calibrate the radome-based measurements of these angles.
\end_layout

\begin_layout Enumerate
LAMS provides an independent measurement of the airspeed, so from that measureme
nt it is possible to determine the expected dynamic pressure.
 This was used previously(Cooper et al., 2014) to calibrate not only the
 dynamic pressure but also the static pressure as measured on the C-130.
 However, since then the offset between the avionic static pressure and
 the research static pressure calibrated in this way has changed, so it
 is important to learn if the static defect actually changed or perhaps
 the avionic value changed.
 This has an important effect on the longitudinal component of the measured
 wind as well.
 ARISTO-2016, esp.
\begin_inset space ~
\end_inset

the last flight, provided an opportunity to extend the fit conditions to
 cover low-altitude flight of the C-130.
\end_layout

\begin_layout Enumerate
The paper by Cooper et al.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset citation
LatexCommand citet
key "CooperEtAl2014"

\end_inset

) developed a method for measuring temperature using the LAMS, which might
 have potential to provide a valid measurement of temperature in clouds.
 However, only a small sample of measurements were available for use in
 that paper, so it will be useful to explore if further measurements from
 ARISTO help characterize this measurement.
\end_layout

\begin_layout Enumerate
The method used to calibrate the radome is based primarily on slowly varying
 measurements, such as the variation in angle-of-attack during a speed run.
 It is of concern that the calibration used might not apply in the case
 of rapidly changing flight conditions, when for example there might be
 transient adjustment of the airflow pattern toward a new steady state.
 Because the LAMS measures wind well ahead of the aircraft, such effects
 should not appear in the LAMS-based measurements, so a comparison of the
 LAMS-based and radome-based measurements might either identify transient-respon
se problems or place limits on how large such effects might be.
 Some rapid changes in pitch were included in the last flight of ARISTO-2016
 that can be used for this study.
\end_layout

\begin_layout Subsection
Data processing
\end_layout

\begin_layout Standard
The original netCDF files, with names like ARISTO2017rf01.nc, contain histograms
 of the LAMS frequency measurements, with names like BEAM{1â€“4}_LAMS.
 For ARISTO-2017, Matt Hayman produced auxiliary files with names like ARISTO201
7rf04_LAMS_TAS_Update.nc .
 These files contain 28 new variables, in particular line-of-sight speeds
 (V_LOS_Beam{1-3} and cartesion-coordinate velocity components (AIRSPEED_{X,Y,Z}
_LAMS) in the LAMS coordinate system.
 The files also include variables V_LOS_Beamx_Uncertainty, estimates of
 the uncertainty in the line-of-sight airspeeds, which have values ranging
 from 0 to 10.
\begin_inset Foot
status open

\begin_layout Plain Layout
It appears that values of 0 are where there is no measurement (e.g., before
 takeoff), values of 10 indicate low-uncertainty estimates that perhaps
 should be excluded from the present study, and the remaining values mostly
 range between 0 and 1 and are the values to be used in this study.
 Most are below 0.1, so it may be useful to consider only those measurements
 with associated uncertainty larger than 0 but smaller than 0.1.
 This needs to be checked with Matt.
\end_layout

\end_inset

 Additional variables (AIRSPEED_{X,Y,Z}_EST) are the result of Kalman-filter
 adjustment using measurements from LAMS and the standard system, so they
 should not be used for the present study.
 Some additional variables are present in these files, but the line-of-sight
 speeds will be the primary input used here.
\end_layout

\begin_layout Standard
The processing chain used was as follows:
\end_layout

\begin_layout Enumerate
A Python routine, with minor modifications from that used previously in
 the 2014 study and the C-130 study that used ARISTO-2015 and ARISTO-2016,
 was used to find line-of-sight airspeeds along all the beams.
 It is LAMS_ARISTO.py and the version used is in the directory ~cooperw/RStudio/A
RISTO-2017.
 It reads the original netCDF file containing the beam histograms in variables
 BEAMx_LAMS, each a 512-element histogram.
\begin_inset Foot
status open

\begin_layout Plain Layout
The long_name attributes are 
\begin_inset Quotes eld
\end_inset

LAMS Histogram Maximums
\begin_inset Quotes erd
\end_inset

 â€“ this should be changed because one must find the peak from the 512-element
 array.
\end_layout

\end_inset

 The new variables produced by this Python routine are BEAMxspeed where
 x is {1â€“4}.
 
\end_layout

\begin_layout Enumerate
The variables V_LOS_Beamx are produced by Matt's processing.
 They are in separate netCDF files that have only the new variables, so
 they must be merged into the composite data.frame so they can be used convenient
ly with the other standard variables and the BEAMxspeed variables.
 This is done by the R code in the 
\begin_inset Quotes eld
\end_inset

merge: chunk, which is included here for reference and is not executed because
 all four beams have been processed in this way and saved in a composite
 data.frame named DataM.
\begin_inset Foot
status open

\begin_layout Plain Layout
Because the files produced by Matt did not have RAF-standard times, the
 
\begin_inset Quotes eld
\end_inset

merge
\begin_inset Quotes erd
\end_inset

 chunk includes reference to a special version of getNetCDF called getNetCDFMH()
 that assigned the correct times so that the measurements could be merged
 with the Python-produced files.
\end_layout

\end_inset

 The individual flights are identified by the variable RF containing the
 flight number, so individual flights can be selected via, e.g., DataM[DataM$RF=4,
].
\end_layout

\begin_layout Enumerate
The subsequent analysis is then contained in this file (ARISTO-LAMS2017.Rnw).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<merge, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# merge Matt's file (name like ARISTO2017rf04_LAMS_TAS_Update.nc) with standard
 to get
\end_layout

\begin_layout Plain Layout

# rf04_MH.nc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- 'ARISTO2017'
\end_layout

\begin_layout Plain Layout

source ('./getNetCDFMH.R')
\end_layout

\begin_layout Plain Layout

transferAttributes <- function (d, dsub) {  
\end_layout

\begin_layout Plain Layout

  ds <- dsub
\end_layout

\begin_layout Plain Layout

  ## ds and dsub are the new variables; d is the original
\end_layout

\begin_layout Plain Layout

  for (nm in names (ds)) {
\end_layout

\begin_layout Plain Layout

    var <- sprintf ("d$%s", nm)
\end_layout

\begin_layout Plain Layout

    A <- attributes (eval (parse (text=var)))
\end_layout

\begin_layout Plain Layout

    if (!grepl ('Time', nm)) {
\end_layout

\begin_layout Plain Layout

      A$dim[1] <- nrow(ds)
\end_layout

\begin_layout Plain Layout

      A$class <- NULL
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      A$dim <- nrow (ds)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    attributes (ds[,nm]) <- A
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  A <- attributes (d)
\end_layout

\begin_layout Plain Layout

  A$Dimensions$Time$len <- nrow (ds)
\end_layout

\begin_layout Plain Layout

  A$row.names <- 1:nrow (ds)
\end_layout

\begin_layout Plain Layout

  A$names <- names (ds)
\end_layout

\begin_layout Plain Layout

  attributes (ds) <- A
\end_layout

\begin_layout Plain Layout

  return(ds)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (Flight in 1:4) {
\end_layout

\begin_layout Plain Layout

  standardFile <- sprintf ('%s%s/%srf%02dLAMS.nc', DataDirectory(), 
\end_layout

\begin_layout Plain Layout

                           Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

  MHFile <- sprintf ('%s%s/%srf%02d_LAMS_TAS_Update.nc', 
\end_layout

\begin_layout Plain Layout

                     DataDirectory(), Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

  netCDFfile = nc_open (standardFile)
\end_layout

\begin_layout Plain Layout

  ATTG <- ncatt_get (netCDFfile, 0)   # get list of global attributes
\end_layout

\begin_layout Plain Layout

  Time <- ncvar_get (netCDFfile, "Time")
\end_layout

\begin_layout Plain Layout

  Time_units <- ncatt_get (netCDFfile, 'Time', 'units')
\end_layout

\begin_layout Plain Layout

  ## special getNetCDFMatt.R uses this to get POSIX time
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF(standardFile, 'ALL')
\end_layout

\begin_layout Plain Layout

  DataMH <- getNetCDFMH(MHFile, 'ALL')
\end_layout

\begin_layout Plain Layout

  if (Flight == 3) {Data <- Data[c(-1,-2),]}
\end_layout

\begin_layout Plain Layout

  DataM <- cbind(Data, DataMH)
\end_layout

\begin_layout Plain Layout

  # DataM <- transferAttributes (DataMH, DataM) # doesn't work
\end_layout

\begin_layout Plain Layout

  DataM <- transferAttributes (Data, DataM)  ## from Data to DataM
\end_layout

\begin_layout Plain Layout

  save(DataM, file=sprintf('DataM%d.Rdata', Flight))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## the above saves flight-1--4 data.
 
\end_layout

\begin_layout Plain Layout

## next: load and merge
\end_layout

\begin_layout Plain Layout

load('DataM1.Rdata') 
\end_layout

\begin_layout Plain Layout

DataM1 <- DataM 
\end_layout

\begin_layout Plain Layout

DataM1$RF <- 1 
\end_layout

\begin_layout Plain Layout

load('DataM2.Rdata') 
\end_layout

\begin_layout Plain Layout

DataM2 <- DataM 
\end_layout

\begin_layout Plain Layout

DataM2$RF <- 2 
\end_layout

\begin_layout Plain Layout

load('DataM3.Rdata') 
\end_layout

\begin_layout Plain Layout

DataM3 <- DataM 
\end_layout

\begin_layout Plain Layout

DataM3$RF <- 3 
\end_layout

\begin_layout Plain Layout

load('DataM4.Rdata') 
\end_layout

\begin_layout Plain Layout

DataM4 <- DataM 
\end_layout

\begin_layout Plain Layout

DataM4$RF <- 4 
\end_layout

\begin_layout Plain Layout

N1 <- names(DataM1) 
\end_layout

\begin_layout Plain Layout

N2 <- names(DataM2) 
\end_layout

\begin_layout Plain Layout

N3 <- names(DataM3) 
\end_layout

\begin_layout Plain Layout

N4 <- names(DataM4) 
\end_layout

\begin_layout Plain Layout

DataM2 <- DataM2[, N2[N2 %in% N1]] 
\end_layout

\begin_layout Plain Layout

DataM4 <- DataM4[, N4[N4 %in% N3]] 
\end_layout

\begin_layout Plain Layout

## ensure that variable names are the same (need to exclude extraneous Time
 variable)
\end_layout

\begin_layout Plain Layout

inx <- which(!(names(DataM4) %in% names(DataM1))) ## index to bad variable
\end_layout

\begin_layout Plain Layout

DataM1 <- DataM1[, -inx] 
\end_layout

\begin_layout Plain Layout

DataM2 <- DataM2[, -inx] 
\end_layout

\begin_layout Plain Layout

DataM3 <- DataM3[, -inx] 
\end_layout

\begin_layout Plain Layout

DataM4 <- DataM4[, -inx] 
\end_layout

\begin_layout Plain Layout

DataM <- rbind(DataM1, DataM2) 
\end_layout

\begin_layout Plain Layout

DataM <- rbind(DataM, DataM3) 
\end_layout

\begin_layout Plain Layout

DataM <- rbind(DataM, DataM4) 
\end_layout

\begin_layout Plain Layout

save(DataM, file='DataM.Rdata')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although the Python routine calculated horizontal wind veriables and other
 results derived from the line-of-sight airspeeds, all such variables were
 recalculated in the present R routine (this file) to generate measurements
 of vertical and horizontal wind, airspeed, and angles of attack and sideslip.
 For airspeed, angle of attack, and sideslip, these steps were used:
\end_layout

\begin_layout Enumerate
The three-beam measurements were used to determine a three-dimensional relative
 wind vector 
\series bold
RW
\series default
={
\begin_inset Formula $\mathrm{RW}_{x},\,\mathrm{RW}_{y},\,\mathrm{RW_{z}}$
\end_inset

}
\series bold
 
\series default
with components inbound along the longitudinal forward, lateral starboard,
 and lateral downward axis in the coordinate frame of the LAMS IRU (with
 attitude angles CPITCH, CROLL, CTHDG).
 The algorithm is documented in LAMSprocessing4Bwind.pdf.
 However, the three-beam version is used here.
\end_layout

\begin_layout Enumerate
The airspeed is then the magnitude of the vector 
\series bold
RW
\series default
.
\end_layout

\begin_layout Enumerate
The angle of attack is 
\begin_inset Formula $\alpha=\arctan\left(\mathrm{RW}_{z}/\mathrm{RW}_{x}\right)$
\end_inset

 and the sideslip angle is 
\begin_inset Formula $\beta=\arctan\left(\mathrm{RW}_{y}/\mathrm{RW}_{x}\right)$
\end_inset

.
 These are in the reference frame of the LAMS (i.e., that defined by the CMIGITS
 IRU).
\end_layout

\begin_layout Standard
For measurements of wind, the Ranadu function Ranadu::WindProcessor() was
 used to calculate the wind based on LAMS-based variables for airspeed,
 angle of attack, and sideslip and the CMIGITS-provided attitude angles
 and ground-speed components.
 The complementary-filter adjustment provided by this function is suppressed
 because the Kalman-filter processing in the CMIGITS accounts for the GPS-provid
ed measurements of ground speed.
\begin_inset Foot
status open

\begin_layout Plain Layout
Some adjustment may be needed to these values because I think the GPS antenna
 used is the standard one mounted below the fuselage and therefore separated
 from the LAMS pod.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For completeness, here are suggested procedures for using the Python routine
 LAMS_ARISTO.py, with comments regarding future use with new data files:
\end_layout

\begin_layout Enumerate
On tikal, copy the routine ~cooperw/ARISTO-2017/LAMS_ARISTO.py to another
 directory where you have write permission.
\end_layout

\begin_layout Enumerate
On lines 254 and 255, change the names of the data file and the directory
 containing the file to be processed.
 Do not include the trailing 
\begin_inset Quotes eld
\end_inset

.nc
\begin_inset Quotes erd
\end_inset

 in the file name.
 Save the edited file.
 CAUTION: This routine will create a new file in that same directory with
 
\begin_inset Quotes eld
\end_inset

LAMS
\begin_inset Quotes erd
\end_inset

 appended to the name supplied, and if that file is present it will overwrite
 the file.
 This won't overwrite Matt's files because it adds 
\begin_inset Quotes eld
\end_inset

LAMS
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

_LAMS
\begin_inset Quotes erd
\end_inset

, but if his files ending in 
\begin_inset Quotes eld
\end_inset

_LAMS
\begin_inset Quotes erd
\end_inset

 are used the new file will end in 
\begin_inset Quotes eld
\end_inset

_LAMSLAMS
\begin_inset Quotes erd
\end_inset

.
 In that case, the new file will contain the line-of-sight speeds obtained
 by both algorithms, in Matt's case with the names Beam1_LAMS â€“ Beam4_LAMS
 and in the case of the Python program with names BEAM1speed â€“ BEAM4speed.
 Note, however, that these will not be used in the following except, when
 present, for comparison tests.
 Instead, Matt's variables 
\begin_inset Quotes eld
\end_inset

V_LOS_Beamx
\begin_inset Quotes erd
\end_inset

 will be used.
\end_layout

\begin_layout Enumerate
Run the program using the command 
\begin_inset Quotes eld
\end_inset

python LAMS_ARISTO.py
\begin_inset Quotes erd
\end_inset

.
 There will be regular messages during processing, ending (if successful)
 with the message 
\begin_inset Quotes eld
\end_inset

Reached end of routine ...
\begin_inset Quotes erd
\end_inset

.
 This will typically take a few minutes.
 If this fails immediately, there may be a problem with the available python
 packages that need updating or changing.
 In particular, the 
\begin_inset Quotes eld
\end_inset

netCDF4
\begin_inset Quotes erd
\end_inset

 python package must be present.
\end_layout

\begin_layout Enumerate
On successful completion, there should then be a new file with a name ending
 in 
\begin_inset Quotes eld
\end_inset

LAMS.nc
\begin_inset Quotes erd
\end_inset

 in the prescribed working directory.
 It should be slightly larger than the original file because a few variables
 are added containing the line-of-sight LAMS speeds and some derived quantities.
 These are then the netCDF files that are read by the next routine to produce
 the final document,.
\end_layout

\begin_layout Standard
The next step is then to run the present routine, 
\begin_inset Quotes eld
\end_inset

ARISTO-LAMS.Rnw
\begin_inset Quotes erd
\end_inset

, in RStudio to generate the PDF document.
 That program contains a suppressed R chunk called 'merge' that should be
 executed on the first run to merge Matt's variables into this file.
 After the first run, the program will load the merged data.frame from 
\begin_inset Quotes eld
\end_inset

DataM.Rdata
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The first comparison shown is the along-beam measurements of airspeed from
 LAMS in comparison to the wind vector from the standard wind-sensing system
 projected in the direction of the beams.
 For these plots, the relative-wind vector from the standard radome-based
 system is transformed to the Earth-relative l-frame and then to the reference
 frame of the LAMS, here called the g-frame by analogy to the gustpod reference
 frame discussed elsewhere.
 This gives the relative-wind vector in the LAMS reference frame, which
 (like the a-frame) has x-axis forward, y-axis starboard and z-axis downward.
 The dot product of the unit vectors representing the orientations of the
 LAMS beams with the LAMS-relative wind then gives the expected along-beam
 airspeeds as predicted from the standard measurement of relative wind.
 Those unit vectors
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It would be useful to learn if there are better values for these angles
 for ARISTO-2017.
\end_layout

\end_inset

 are:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\left(\begin{array}{ccc}
\cos(35) & 0 & \sin(35)\\
1 & 0 & 0\\
\cos(35) & -\sin(35)\sin(60) & -\sin(35)\cos(60)\\
\cos(35) & \sin(35)\sin(60) & -\sin(35)\cos(60)
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<beamProcessing, echo=FALSE, include=TRUE, fig.cap=c('Airspeed measurements
 along LAMS beams for ARISTO2017 flights 1--4.
 The prediction is based on transforming the standard radome-based wind
 vector to the LAMS reference frame and then finding the projection of that
 wind along the directions of the LAMS beams.', 'Airspeed measurements along
 LAMS beams for ARISTO2017 flights 1--4.
 The prediction is based on transforming the standard radome-based wind
 vector to the LAMS reference frame and then finding the projection of that
 wind along the directions of the LAMS beams.'), cache=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Theta <- c(35, 0, 35, 35) * pi / 180  ## need new values for ARISTO2017
\end_layout

\begin_layout Plain Layout

Phi <- c(180, 0, 60, -60) * pi / 180
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

processWind <- function(Data) {
\end_layout

\begin_layout Plain Layout

  Data$BEAM1speed <- zoo::na.approx (as.vector(Data$BEAM1speed), maxgap=1000,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  Data$BEAM2speed <- zoo::na.approx (as.vector(Data$BEAM2speed), maxgap=1000,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  Data$BEAM3speed <- zoo::na.approx (as.vector(Data$BEAM3speed), maxgap=1000,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  Data$BEAM4speed <- zoo::na.approx (as.vector(Data$BEAM4speed), maxgap=1000,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  ## replace with Matt's values
\end_layout

\begin_layout Plain Layout

  if (PCA) {
\end_layout

\begin_layout Plain Layout

    Data$BEAM1speed <- zoo::na.approx (as.vector(Data$V_LOS_Beam1), maxgap=1000,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    Data$BEAM2speed <- zoo::na.approx (as.vector(Data$V_LOS_Beam2), maxgap=1000,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    Data$BEAM3speed <- zoo::na.approx (as.vector(Data$V_LOS_Beam3), maxgap=1000,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

## Beam4 is not processed by Matt; leave as SG value, but don't use below
\end_layout

\begin_layout Plain Layout

    Data$BEAM4speed <- zoo::na.approx (as.vector(Data$BEAM4speed), maxgap=1000,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ## try to fix CTHDG_LAMS bad points in transition through 180: (may no
 longer be needed)
\end_layout

\begin_layout Plain Layout

  if(FALSE) {
\end_layout

\begin_layout Plain Layout

    for (i in 2:(nrow(Data)-1)) {
\end_layout

\begin_layout Plain Layout

      if (is.na(Data$CTHDG_LAMS[i]) || is.na(Data$CTHDG_LAMS[i-1]) || is.na(Data$CT
HDG_LAMS[i+1])) {next}
\end_layout

\begin_layout Plain Layout

       if (abs(Data$CTHDG[i-1]-Data$CTHDG_LAMS[i+1]) > 10.) {next}
\end_layout

\begin_layout Plain Layout

      if ((Data$CTHDG_LAMS[i-1] < 180.) && (Data$CTHDG_LAMS[i+1] > 180))
 {Data$CTHDG_LAMS[i] <- NA}
\end_layout

\begin_layout Plain Layout

      if ((Data$CTHDG_LAMS[i-1] > 180.) && (Data$CTHDG_LAMS[i+1] < 180))
 {Data$CTHDG_LAMS[i] <- NA}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Data$CTHDG_LAMS <- zoo::na.approx (as.vector(Data$CTHDG_LAMS), maxgap=1000,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # also need the distances from the IRS to LAMS: (x,y,z)
\end_layout

\begin_layout Plain Layout

  LL = c(-10.305, -6.319, 1.359)                # these are GV values
\end_layout

\begin_layout Plain Layout

  # unit vectors along beams are then:
\end_layout

\begin_layout Plain Layout

  #   a[i] = [cos(Theta[i]), -sin(Theta[i])*sin(Phi[i]), sin(Theta[i])*cos(Phi[i
])]
\end_layout

\begin_layout Plain Layout

  # and the dot products with the (i,j,k) unit vectors give the direction
 cosine matrix:
\end_layout

\begin_layout Plain Layout

  S = c(cos(Theta[1]), -sin(Theta[1])*sin(Phi[1]), sin(Theta[1])*cos(Phi[1]),
 
\end_layout

\begin_layout Plain Layout

                 cos(Theta[2]), -sin(Theta[2])*sin(Phi[2]), sin(Theta[2])*cos(Ph
i[2]), 
\end_layout

\begin_layout Plain Layout

                 cos(Theta[3]), -sin(Theta[3])*sin(Phi[3]), sin(Theta[3])*cos(Ph
i[3]))
\end_layout

\begin_layout Plain Layout

  ## S4 is the four-beam solution, not used here
\end_layout

\begin_layout Plain Layout

  S4 <- c(S, cos(Theta[4]), -sin(Theta[4])*sin(Phi[4]), sin(Theta[4])*cos(Phi[4]
))
\end_layout

\begin_layout Plain Layout

  dim(S) <- c(3,3)
\end_layout

\begin_layout Plain Layout

  Si = t(solve(S))  # calculate the inverse of S -- this is the 3-beam version
\end_layout

\begin_layout Plain Layout

  ## the following commented lines are the python code:
\end_layout

\begin_layout Plain Layout

  # S4 = np.vstack ((S, [cos(Theta[3]), -sin(Theta[3])*sin(Phi[3]), sin(Theta[3])
*cos(Phi[3])]))
\end_layout

\begin_layout Plain Layout

  # StS =  linalg.inv (ma.dot (S4.T, S4))
\end_layout

\begin_layout Plain Layout

  # M = ma.dot (StS, S4.T)      # matrix for finding relative wind from 4-beam
 LAMS
\end_layout

\begin_layout Plain Layout

  dim(S4) <- c(3,4)
\end_layout

\begin_layout Plain Layout

  StS <- S4 %*% t(S4)
\end_layout

\begin_layout Plain Layout

  StS <- solve(StS)
\end_layout

\begin_layout Plain Layout

  M <- StS %*% S4    ## this isn't used here
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  A = c(Data$BEAM1speed, Data$BEAM2speed, Data$BEAM3speed)
\end_layout

\begin_layout Plain Layout

  A4 <- c(A, Data$BEAM4speed)
\end_layout

\begin_layout Plain Layout

  dim(A4) <- c(nrow(Data), 4)
\end_layout

\begin_layout Plain Layout

  dim(A) <- c(nrow(Data), 3)
\end_layout

\begin_layout Plain Layout

  RW = t (Si %*% t(A))    # gives u, v, w components, RW[,1] is u
\end_layout

\begin_layout Plain Layout

  RW2 <- t (M %*% t(A4))
\end_layout

\begin_layout Plain Layout

  ## calculate the error in the 4-beam solution:
\end_layout

\begin_layout Plain Layout

  A4P <- t (t (S4) %*% t (RW2)) - A4
\end_layout

\begin_layout Plain Layout

  CSQ <- A4P[,1]^2 + A4P[,2]^2 + A4P[,3]^2 + A4P[,4]^2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## set up a special data.frame for calculating wind:
\end_layout

\begin_layout Plain Layout

  D <- data.frame("Time"=Data$Time)
\end_layout

\begin_layout Plain Layout

  # D$TASX <- sqrt(RW2[,1]^2 + RW2[,2]^2 + RW2[,3]^2)  ## not used
\end_layout

\begin_layout Plain Layout

  D$TASX3 <- sqrt(RW[,1]^2 + RW[,2]^2 + RW[,3]^2)    ## 3-beam version
\end_layout

\begin_layout Plain Layout

  D$TASCSQ <- CSQ ## not used
\end_layout

\begin_layout Plain Layout

  ## The following substitutions replace standard variables with LAMS-provided
\end_layout

\begin_layout Plain Layout

  ## variables because the function WindProcessor() expects these names
\end_layout

\begin_layout Plain Layout

  D$TASX <- D$TASX3   ## use the LAMS-provided value
\end_layout

\begin_layout Plain Layout

  D$ATTACK <- atan (RW[, 3] / RW[, 1]) * 180 / pi
\end_layout

\begin_layout Plain Layout

  D$SSLIP <-  atan (RW[, 2] / RW[, 1]) * 180 / pi
\end_layout

\begin_layout Plain Layout

  D$GGVEW <- Data$CVEW_LAMS  
\end_layout

\begin_layout Plain Layout

  D$GGVNS <- Data$CVNS_LAMS
\end_layout

\begin_layout Plain Layout

  D$GGVSPD <- Data$CVSPD_LAMS
\end_layout

\begin_layout Plain Layout

  D$VEW <- Data$CVEW_LAMS
\end_layout

\begin_layout Plain Layout

  D$VNS <- Data$CVNS_LAMS
\end_layout

\begin_layout Plain Layout

  D$THDG <- Data$CTHDG_LAMS
\end_layout

\begin_layout Plain Layout

  D$ROLL <- Data$CROLL_LAMS
\end_layout

\begin_layout Plain Layout

  D$PITCH <- Data$CPITCH_LAMS
\end_layout

\begin_layout Plain Layout

  ## save some variables for transfer into DataM upon return:
\end_layout

\begin_layout Plain Layout

  D$V_LOS_Beam1 <- Data$BEAM1speed
\end_layout

\begin_layout Plain Layout

  D$V_LOS_Beam2 <- Data$BEAM2speed
\end_layout

\begin_layout Plain Layout

  D$V_LOS_Beam3 <- Data$BEAM3speed
\end_layout

\begin_layout Plain Layout

  D$V_LOS_Beam4 <- Data$BEAM4speed  ## this is really the SG-poly-provided
 value
\end_layout

\begin_layout Plain Layout

  D$VXG <- RW[,1]
\end_layout

\begin_layout Plain Layout

  D$VYG <- RW[,2]
\end_layout

\begin_layout Plain Layout

  D$VZG <- RW[,3]
\end_layout

\begin_layout Plain Layout

  # if (grepl('rf03', fname)) {
\end_layout

\begin_layout Plain Layout

  #   rg <- setRange (D$Time, 192300,213000)
\end_layout

\begin_layout Plain Layout

  #   D <- D[rg, ]
\end_layout

\begin_layout Plain Layout

  # }
\end_layout

\begin_layout Plain Layout

  ## use standard wind processor 
\end_layout

\begin_layout Plain Layout

  ### rotation-rate corrections should be removed first, 
\end_layout

\begin_layout Plain Layout

  ### but for standard routine they are insignificant so will be ignored
 for now.
\end_layout

\begin_layout Plain Layout

  DW <- WindProcessor (data=D)
\end_layout

\begin_layout Plain Layout

  return (DW)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DW <- processWind (DataM)
\end_layout

\begin_layout Plain Layout

DataM$TASL <- DW$TASX3
\end_layout

\begin_layout Plain Layout

DataM$WDL <- DW$WDN
\end_layout

\begin_layout Plain Layout

DataM$WSL <- DW$WSN
\end_layout

\begin_layout Plain Layout

DataM$WIL <- DW$WIN
\end_layout

\begin_layout Plain Layout

DataM$VXG <- DW$VXG
\end_layout

\begin_layout Plain Layout

DataM$VYG <- DW$VYG
\end_layout

\begin_layout Plain Layout

DataM$VZG <- DW$VZG
\end_layout

\begin_layout Plain Layout

# DataM$V_LOS_Beam1 <- DW$V_LOS_Beam1  ## these values have interpolation,
\end_layout

\begin_layout Plain Layout

                                       ## so don't make this substitution
\end_layout

\begin_layout Plain Layout

uv <- c(cos(Theta), -sin(Theta)*sin(Phi), -sin(Theta)*cos(Phi))
\end_layout

\begin_layout Plain Layout

dim(uv) <- c(4,3)
\end_layout

\begin_layout Plain Layout

DataM$UXA <- with(DataM, TASX / sqrt(1 + tan(ATTACK*pi/180)^2 + tan(SSRD*pi/180)
^2))
\end_layout

\begin_layout Plain Layout

RWA <- with(DataM, c(UXA, UXA*tan(ATTACK*pi/180), UXA*tan(SSRD*pi/180)))
\end_layout

\begin_layout Plain Layout

dim(RWA) <- c(nrow(DataM), 3)
\end_layout

\begin_layout Plain Layout

RWL <- XformLA(DataM, RWA)
\end_layout

\begin_layout Plain Layout

## make small adjustments to LAMS attitude angles, as indicated by LOS plots:
\end_layout

\begin_layout Plain Layout

# DataM$CPITCH_LAMS <- DataM$CPITCH_LAMS + 2
\end_layout

\begin_layout Plain Layout

# DataM$CTHDG_LAMS <- DataM$CTHDG_LAMS + 2
\end_layout

\begin_layout Plain Layout

DLAMS <- with(DataM, data.frame(Time, ROLL=CROLL_LAMS, PITCH=CPITCH_LAMS+2,
 THDG=CTHDG_LAMS+2))
\end_layout

\begin_layout Plain Layout

RWB <- XformLA(DLAMS, RWL, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

LOSV <- RWB %*% t(uv)
\end_layout

\begin_layout Plain Layout

DataM$BX1 <- LOSV[,1]
\end_layout

\begin_layout Plain Layout

DataM$BX2 <- LOSV[,2]
\end_layout

\begin_layout Plain Layout

DataM$BX3 <- LOSV[,3]
\end_layout

\begin_layout Plain Layout

DataM$BX4 <- LOSV[,4]
\end_layout

\begin_layout Plain Layout

# impose restrictions here
\end_layout

\begin_layout Plain Layout

DataR <- DataM[DataM$TASX > 90,]
\end_layout

\begin_layout Plain Layout

DataR <- DataR[abs(DataR$ROLL) < 3, ]
\end_layout

\begin_layout Plain Layout

DataR <- DataR[DataR$V_LOS_Beam2_Uncertainty > 0.001 & DataR$V_LOS_Beam2_Uncertai
nty < 0.1, ]
\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol=2), widths=c(8,7), heights=c(5,5)) 
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1, oma=c(1.1,0,0,0)) 
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(BX1, BEAM1speed), type='p', pch=20, col='blue',
 xlab='predicted from std wind', ylab='LAMS measurement')) 
\end_layout

\begin_layout Plain Layout

lines(c(-50, 300), c(-50, 300), col='darkorange', lwd=3, lty=2) 
\end_layout

\begin_layout Plain Layout

title('beam 1') 
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,2,1,1)+0.1) 
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(BX2, BEAM2speed), type='p', pch=20, col='blue',
 xlab='predicted from std wind', ylab='LAMS measurement')) 
\end_layout

\begin_layout Plain Layout

lines(c(-50, 300), c(-50, 300), col='darkorange', lwd=3, lty=2) 
\end_layout

\begin_layout Plain Layout

title('beam 2')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1, oma=c(1.1,0,0,0))
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(BX3, BEAM3speed), type='p', pch=20, col='blue',
 xlab='predicted from std wind', ylab='LAMS measurement'))
\end_layout

\begin_layout Plain Layout

lines(c(-50, 300), c(-50, 300), col='darkorange', lwd=3, lty=2)
\end_layout

\begin_layout Plain Layout

title('beam 3')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,2,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(BX4, BEAM4speed), type='p', pch=20, col='blue',
 xlab='predicted from std wind', ylab='LAMS measurement'))
\end_layout

\begin_layout Plain Layout

lines(c(-50, 300), c(-50, 300), col='darkorange', lwd=3, lty=2)
\end_layout

\begin_layout Plain Layout

title('beam 4')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results are shown in Figs.
\begin_inset space ~
\end_inset

1 and 2, after adjustments to the pitch and heading angles from the CMIGITS,
 each by 
\begin_inset Formula $+2^{\circ}$
\end_inset

.
 Without these shifts, there are obvious offsets in the cases of beams 1
 and 3.
 This suggests that the LAMS IRU may not be oriented exactly along the LAMS
 axis.
 The plot for beam 4 is based on the approach that uses Savitzky-Golay polynomia
ls
\begin_inset Foot
status open

\begin_layout Plain Layout
Analysis using the S-G polynomials produced results in good agreement with
 Matt's, but were more often missing, especially in cases where Matt assigns
 an uncertainty of more than 1 m/s.
\end_layout

\end_inset

 because Matt did not produce beam-4 LOS values.
 These have not been used in the TAS calculation and were often missing.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plotWind, echo=FALSE, include=TRUE, fig.cap='Wind measurements from ARISTO-2017
 flight 3.
 The blue lines are from the standard wind-sensing system and the green
 lines are from LAMS.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- 3
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1, oma=c(1.1,0,0,0))
\end_layout

\begin_layout Plain Layout

with(DataM[DataM$RF == Flight & DataM$TASX > 50,], plotWAC(data.frame(Time,
 WDC, WDL), legend.position='bottom', ylab='WD [deg]'))  #, ylim=c(250,360))
\end_layout

\begin_layout Plain Layout

#title(fname)
\end_layout

\begin_layout Plain Layout

with(DataM[DataM$RF == Flight & DataM$TASX > 50, ], plotWAC(data.frame(Time,
 SmoothInterp(WSC), SmoothInterp(WSL)), ylim=c(0,50), legend.position='topright',
 ylab='WS [m/s]'))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(DataM[DataM$RF == Flight & DataM$TASX > 50, ], plotWAC(data.frame(Time,
 SmoothInterp(WIC), SmoothInterp(WIL)), ylim=c(-5,5), legend.position='top',
 ylab='WI [m/s]'))
\end_layout

\begin_layout Plain Layout

abline(h=0, col='darkorange', lty=2, lwd=3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tasPlot, echo=FALSE, include=TRUE, fig.cap='Comparison of measurements
 of airspeed by the conventional system (TASX) and by the LAMS (TASL).
 Restrictions have been applied to isolate a subset of measurements expected
 to be most reliable, as discussed in the text.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:1, ncol=1), widths=1, heights=6)
\end_layout

\begin_layout Plain Layout

# with(DataR, plotWAC(data.frame(Time, TASX, TASL)))
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(TASL, TASX),xlab='TASX [m/s]', ylab='TASL
 [m/s]', type='p', pch=20, col='blue'))
\end_layout

\begin_layout Plain Layout

lines(c(50,300), c(50,300), col='darkorange', lwd=3, lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The airspeeds obtained by the LAMS and by the standard pitot-tube-based
 wind sensing system are in excellent agreement, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tasPlot}
\end_layout

\end_inset

.
 A regression fit to TASX as a linear function of TASL gives an intercept
 coefficient of -0.12 m/s and a slope coefficient of 0.9994, with a residual
 standard deviation of 0.43 m/s for 19,075 measurements from flights 1â€“4
 of ARISTO-2017.
 These qualifications were imposed for a measurement to be accepted in these
 plots: 
\end_layout

\begin_layout Enumerate
TASX > 90, to eliminate flight periods with possible flaps during takeoff
 and landing;
\end_layout

\begin_layout Enumerate
|roll| < 
\begin_inset Formula $3^{\circ}$
\end_inset

, to eliminate turns;
\end_layout

\begin_layout Enumerate
0.001< V_LOS_Beam2_Uncertainty < 0.1, to eliminate the points found by Matt
 Hayman's processing to have higher uncertainty, or in the case of value
 0 to be missing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<TASfit, echo=TRUE, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lfTAS <- lm(TASX ~ TASL, data=DataR)
\end_layout

\begin_layout Plain Layout

SummarizeFit(lfTAS)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Recommendation Regarding PCORS
\end_layout

\begin_layout Standard
Because the measurements TASX and TASL agree so well, it does not seem useful
 to adjust the 
\begin_inset Quotes eld
\end_inset

PCOR
\begin_inset Quotes erd
\end_inset

 function for PSF and QCF\SpecialChar endofsentence
 Instead, this check should be regarded as a test
 that the PCOR correction remains appropriate, and it should be left at
 the standard formula for consistency with other projects.
\end_layout

\begin_layout Section
Study of the Pitot-Static Sensor 
\end_layout

\begin_layout Standard
New measurements were available during ARISTO-2017 from a pitot-static sensor
 designed to minimize the problems with high-frequency noise arising from
 line resonance in the standard system.
 The new variables are QCTF and PSTF, representing the dynamic and static
 (ambient) pressure.
 Because the sensor is located in a region where flow distortion around
 the aircraft is severe, the static pressure differs significantly from
 the standard measurements including PSF and PSFC\SpecialChar endofsentence
 However, the static pressure
 is not particularly useful because there is already a good measurement
 of static pressure available from the static-button ports and associated
 sensor.
 It is the measurement of dynamic pressure that is needed to improve high-freque
ncy measurements of wind.
\end_layout

\begin_layout Subsection
A proposed algorithm 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<totalPressure, include=TRUE, echo=FALSE, fig.cap='Total pressure measured
 by the pitot-static tube (PSTF+QCTF) vs the total pressure measured by
 the standard wind-sensing system (QCF+PSF).
 A Deming fit to these two variables gives an offset of 0.015 hPa and a slope
 coefficient of 1.000004, with a standard deviation between measurements
 of 0.14 hPa.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(PSF+QCF, PSTF+QCTF), xlab='PSF+QCF [hPa]',
 
\end_layout

\begin_layout Plain Layout

                    ylab='PSTF+QCTF [hPa]', type='p', pch=20))
\end_layout

\begin_layout Plain Layout

lines(c(300,1200),c(300,1200), col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nevertheless, it is necessary to deal with the static-pressure measurement
 PSTF because QCTF is the difference between the measurements of total pressure
 at the stagnation point in the tube and the measured static pressure.
 The total pressure measurement is PSTF+QCTF, and it is in remarkable agreement
 with PSF+QCF, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:totalPressure}
\end_layout

\end_inset

.
 While the pitot-static measurements could be approached like those of the
 gust-pod, seeking empirical equations that provide a match to QCFC, another
 approach is then to subtract a smoothed version of the ambient pressure
 measured by the standard system (PSFC) from QCTF+PSTF to obtain QCTC.
 PSF does not contain real signal beyond about 0.1
\begin_inset space ~
\end_inset

Hz so removing the noise above that frequency is useful anyway.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<QCTC, include=TRUE, echo=FALSE, fig.cap='The variables QCTC (new variable,
 corrected, from the pitot-static sensor) and QCFC, the standard variable,
 for SOCRATES test flight 4.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DataS <- getNetCDF('/Data/SOCRATES/SOCRATEStf01.nc', standardVariables(c('QCFC',
 'QCTF', 'PSTF', 'PSF', 'QCF', 'PSFC')))
\end_layout

\begin_layout Plain Layout

PSFCF <- SmoothInterp (DataS$PSFC, .Length=0)  ## just interpolate
\end_layout

\begin_layout Plain Layout

DataS$PSFCF <- signal::filtfilt (signal::butter (3, 2/10), PSFCF)
\end_layout

\begin_layout Plain Layout

DataS$QCTC <- with(DataS, QCTF+PSTF-PSFCF)
\end_layout

\begin_layout Plain Layout

with(DataS[DataS$TASX > 90, ], plotWAC(data.frame(Time, QCTC, QCFC), ylab='QC
 corrected [hPa]'))
\end_layout

\begin_layout Plain Layout

meanQCDIF <- with(DataS[DataS$TASX > 90, ], mean(QCTC-QCFC, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

sdQCDIF <- with(DataS[DataS$TASX > 90, ], sd(QCTC-QCFC, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The smoothing can be accomplished either by a low-pass Butterworth filter
 or by Savitzky-Golay smoothing.
 The resulting estimate of the dynamic pressure is then
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathrm{QCTC=QCTF+PSTF-FilterFunction(PSFC,\,.Length=21)}
\]

\end_inset

where 
\begin_inset Quotes eld
\end_inset

FilterFunction
\begin_inset Quotes erd
\end_inset

 represents the choice of smoothing function.
 Here a Butterworth filter will be used with a cutoff frequency of 0.1
\begin_inset space ~
\end_inset

Hz.
 The resulting variable QCTC is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:QCTC}
\end_layout

\end_inset

 along with the standard corrected variable QCFC\SpecialChar endofsentence
 The variables are essentially
 overlapping: The mean difference for the flight shown is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(meanQCDIF, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

hPa and the standard deviation of the difference is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdQCDIF,2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

hPa, so this approach provides a good match to QCFC for 1-Hz measurements.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<PStubeVarSpec, include=TRUE, echo=FALSE, fig.cap='Comparison of the corrected
 dynamic-pressure measurements QCFC (from the standard calculations) and
 QCTC (from the new calculation for the pitot-static sensor).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vars <- c('ATTACK', 'SSLIP', 'GGVEW', 'GGVNS', 'GGVSPD', 'VEW', 'VNS', 'PITCH',
 'ROLL', 'THDG', 'UXC', 'VYC')
\end_layout

\begin_layout Plain Layout

DataS <- getNetCDF('/Data/SOCRATES/SOCRATESrf01HRT.nc', standardVariables(c(Vars,
 'QCFC', 'QCTF', 'PSTF', 'PSF', 'QCF', 'PSFC')))
\end_layout

\begin_layout Plain Layout

Rate <- 25
\end_layout

\begin_layout Plain Layout

PSFCF <- SmoothInterp (DataS$PSFC, .Length=0)  ## just interpolate
\end_layout

\begin_layout Plain Layout

DataS$PSFCF <- signal::filtfilt (signal::butter (3, 2/(10*Rate)), PSFCF)
\end_layout

\begin_layout Plain Layout

DataS$QCTC <- with(DataS, QCTF+PSTF-PSFCF)
\end_layout

\begin_layout Plain Layout

# with(DataS[DataS$TASX > 90, ], plotWAC(data.frame(Time, QCTC, QCFC), ylab='QC
 corrected [hPa]'))
\end_layout

\begin_layout Plain Layout

meanQCDIF <- with(DataS[DataS$TASX > 90, ], mean(QCTC-QCFC, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

sdQCDIF <- with(DataS[DataS$TASX > 90, ], sd(QCTC-QCFC, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

DataS <- DataS[setRange(DataS, 22520, 23040),]
\end_layout

\begin_layout Plain Layout

spans <- 49
\end_layout

\begin_layout Plain Layout

S <- spectrum (ts(DataS$QCTC, frequency=Rate), span=spans, plot=FALSE)
\end_layout

\begin_layout Plain Layout

freq <- S$freq
\end_layout

\begin_layout Plain Layout

fpf <- 2 * S$spec * freq
\end_layout

\begin_layout Plain Layout

S2 <- spectrum(ts(DataS$QCFC, frequency=Rate), span=spans, plot=FALSE)
\end_layout

\begin_layout Plain Layout

freq2 <- S2$freq
\end_layout

\begin_layout Plain Layout

fpf2 <- 2 * S2$spec * freq2
\end_layout

\begin_layout Plain Layout

labx <- 'frequency [Hz]'
\end_layout

\begin_layout Plain Layout

laby <- 'fP(f) for corrected QC'
\end_layout

\begin_layout Plain Layout

xlim <- c(0.001,15)
\end_layout

\begin_layout Plain Layout

ylim <- c(0.001, 1) 
\end_layout

\begin_layout Plain Layout

DF1 <- data.frame(freq, fpf)
\end_layout

\begin_layout Plain Layout

DF2 <- data.frame(freq2, fpf2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(data=DF1)         
\end_layout

\begin_layout Plain Layout

g <- g + geom_path (aes(x=freq, y=fpf, colour='QCTC'), na.rm=TRUE) +    
       xlab(labx) + ylab (laby) 
\end_layout

\begin_layout Plain Layout

g <- g + geom_path (aes(x=freq2, y=fpf2, colour='QCFC'), data=DF2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

cLines <- c('blue', 'forestgreen')
\end_layout

\begin_layout Plain Layout

names(cLines) <- c('QCFC', 'QCTC')
\end_layout

\begin_layout Plain Layout

g <- g + (scale_colour_manual (name='', values=cLines))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4), #limits = xlim, 
\end_layout

\begin_layout Plain Layout

  labels = trans_format("log10", math_format(10^.x))) +           
\end_layout

\begin_layout Plain Layout

  scale_y_log10(breaks =            trans_breaks("log10", function(x) 10^x,
 n=4), #limits = ylim,             
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(10^.x))) +           
\end_layout

\begin_layout Plain Layout

  coord_cartesian(xlim=xlim, ylim=ylim) 
\end_layout

\begin_layout Plain Layout

tasAverage <- mean(DataS$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

ae <- 0.2
\end_layout

\begin_layout Plain Layout

for (i in (-8:0)) {
\end_layout

\begin_layout Plain Layout

  a = ae * 10.^(i*(2/3)) * tasAverage^(2/3)
\end_layout

\begin_layout Plain Layout

  lw = ifelse(i == -4, 1.2, 0.5)
\end_layout

\begin_layout Plain Layout

  DFL <- data.frame(x=xlim, y=c(a/xlim[1]^(2/3), a/xlim[2]^(2/3)))
\end_layout

\begin_layout Plain Layout

  # print(DFL)
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path (data=DFL, aes(x=x, y=y), colour='darkorange', lwd=lw,
 lty=3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

print(g)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<newWind, include=TRUE, echo=FALSE, fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## set up a data.frame for calculating the new wind:
\end_layout

\begin_layout Plain Layout

D <- DataS
\end_layout

\begin_layout Plain Layout

D$QCXC <- DataS$QCTC
\end_layout

\begin_layout Plain Layout

## find new TAS
\end_layout

\begin_layout Plain Layout

TASPT <- TrueAirspeed(MachNumber(DataS$PSFCF, DataS$QCTC, DataS$EWX), DataS$ATX,
 DataS$EWX / DataS$PSFCF)
\end_layout

\begin_layout Plain Layout

D$TASX <- TASPT
\end_layout

\begin_layout Plain Layout

DW <- WindProcessor(D, CompF=FALSE)
\end_layout

\begin_layout Plain Layout

hdg <- DataS$THDG * pi/180
\end_layout

\begin_layout Plain Layout

wd <- DW$WDN * pi/180 + pi
\end_layout

\begin_layout Plain Layout

DataS$UXPT <- DW$WSN * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd))
\end_layout

\begin_layout Plain Layout

hdg <- hdg - pi/2
\end_layout

\begin_layout Plain Layout

DataS$VYPT <- DW$WSN * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd))
\end_layout

\begin_layout Plain Layout

DataS$WDN <- DW$WDN
\end_layout

\begin_layout Plain Layout

DataS$WSN <- DW$WSN
\end_layout

\begin_layout Plain Layout

DataS$WIN <- DW$WIN
\end_layout

\begin_layout Plain Layout

DataS$TASPT <- DW$TASX
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:PStubeVarSpec}
\end_layout

\end_inset

 shows variance spectra from the low-level leg from SOCRATES flight #1,
 2:25:20â€“2:30:40 UTC\SpecialChar endofsentence
 The high-frequency noise is reduced significantly but
 is still present in QCTC, although the level of turbulence is relatively
 low so a noise floor might be expected.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VSpec1, include=TRUE, echo=FALSE, fig.cap='Variance spectra for the measurement
s of vertical wind using the standard method (WIC) and the new pitot-static
 tube (WIN).
 Data from SOCRATES flight 1, 2:25:20--2:30:40.' >>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

spans <- 49
\end_layout

\begin_layout Plain Layout

Rate <- 25
\end_layout

\begin_layout Plain Layout

n1 <- 'WIC'
\end_layout

\begin_layout Plain Layout

n2 <- 'WIN'
\end_layout

\begin_layout Plain Layout

ae <- 0.2  ## use 0.15 for longitudinal spectra
\end_layout

\begin_layout Plain Layout

PlotVSpec <- function (n1, n2, DataS) {
\end_layout

\begin_layout Plain Layout

v1 <- DataS[, n1]
\end_layout

\begin_layout Plain Layout

v2 <- DataS[, n2]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

S <- spectrum (ts(SmoothInterp(v1, .Length=0), frequency=Rate), span=spans,
 plot=FALSE)
\end_layout

\begin_layout Plain Layout

freq <- S$freq
\end_layout

\begin_layout Plain Layout

fpf <- 2 * S$spec * freq
\end_layout

\begin_layout Plain Layout

S2 <- spectrum(ts(SmoothInterp(v2, .Length=0), frequency=Rate), span=spans,
 plot=FALSE)
\end_layout

\begin_layout Plain Layout

freq2 <- S2$freq
\end_layout

\begin_layout Plain Layout

fpf2 <- 2 * S2$spec * freq2
\end_layout

\begin_layout Plain Layout

labx <- 'frequency [Hz]'
\end_layout

\begin_layout Plain Layout

laby <- 'fP(f)'
\end_layout

\begin_layout Plain Layout

xlim <- c(0.001,15)
\end_layout

\begin_layout Plain Layout

ylim <- c(0.001, 1) 
\end_layout

\begin_layout Plain Layout

DF1 <- data.frame(freq, fpf)
\end_layout

\begin_layout Plain Layout

DF2 <- data.frame(freq2, fpf2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(data=DF1)         
\end_layout

\begin_layout Plain Layout

g <- g + geom_path (aes(x=freq, y=fpf, colour=n1), na.rm=TRUE) +        
   xlab(labx) + ylab (laby) 
\end_layout

\begin_layout Plain Layout

g <- g + geom_path (aes(x=freq2, y=fpf2, colour=n2), data=DF2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

cLines <- c('blue', 'forestgreen')
\end_layout

\begin_layout Plain Layout

names(cLines) <- c(n1, n2)
\end_layout

\begin_layout Plain Layout

g <- g + (scale_colour_manual (name='', values=cLines))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4), #limits = xlim, 
\end_layout

\begin_layout Plain Layout

  labels = trans_format("log10", math_format(10^.x))) +           
\end_layout

\begin_layout Plain Layout

  scale_y_log10(breaks =            trans_breaks("log10", function(x) 10^x,
 n=4), #limits = ylim,             
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(10^.x))) +           
\end_layout

\begin_layout Plain Layout

  coord_cartesian(xlim=xlim, ylim=ylim) 
\end_layout

\begin_layout Plain Layout

tasAverage <- mean(DataS$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

for (i in (-8:0)) {
\end_layout

\begin_layout Plain Layout

  a = ae * 10.^(i*(2/3)) * tasAverage^(2/3)
\end_layout

\begin_layout Plain Layout

  lw = ifelse(i == -4, 1.2, 0.5)
\end_layout

\begin_layout Plain Layout

  DFL <- data.frame(x=xlim, y=c(a/xlim[1]^(2/3), a/xlim[2]^(2/3)))
\end_layout

\begin_layout Plain Layout

  # print(DFL)
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path (data=DFL, aes(x=x, y=y), colour='darkorange', lwd=lw,
 lty=3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return(g + theme_WAC())
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

print (PlotVSpec(n1, n2, DataS))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VSpec2, include=TRUE, echo=FALSE, fig.cap='Variance spectra for measurements
 of the longitudinal component of the wind, UXC (standard measurement) and
 UXPT (measurement based on the pitot-static tube).
 Data from the same flight segment as for the previous figure.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

n1 <- 'UXC'
\end_layout

\begin_layout Plain Layout

n2 <- 'UXPT'
\end_layout

\begin_layout Plain Layout

ae <- 0.15
\end_layout

\begin_layout Plain Layout

print (PlotVSpec(n1, n2, DataS))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To see the effect on the wind spectra, winds were recalculated using the
 new value for dynamic pressure.
 The airspeed was calculated in standard ways (including humidity correction
 terms.
 For details and the Ranadu functions involved, see the R code embedded
 with this document.
 For the transverse components of the wind (WIC and VYC), the new results
 essentially duplicated the standard ones, as illustrated in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VSpec1}
\end_layout

\end_inset

.
 The spectrum for the other lateral component (VYC in standard processing)
 showed similar agreement; the plotted spectra were essentially the same.
 For the problematic lateral component, however, the pitot-static tube provided
 significant improvement but still showed evidence of noise at the highest
 frequency.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VSpec2}
\end_layout

\end_inset

 shows significant improvement in comparison to the standard measurement,
 but there is still evidence of noise for the portion of the spectrum above
 about 5_Hz.
 The magnitude of the noise is approximately that expected for a measurement
 precision of 0.2
\begin_inset space ~
\end_inset

m/s, From error propagation using 
\begin_inset Formula $q=0.5\rho v^{2}$
\end_inset

, a relative error in 
\begin_inset Formula $v$
\end_inset

 of about 0.1% would give a relative error in 
\begin_inset Formula $q$
\end_inset

 of 0.2% or about 0.2 hPa in low-level flight.
 This is significantly above the precision expected from the sensor, so
 it isn't clear why the level of noise is as high as it is.
 (I don't have specs for this specific sensor; need to get that to complete
 this argument, which now is based on similar transducers.) In other flight
 segments, the noise level is significantly lower.
\begin_inset Foot
status open

\begin_layout Plain Layout
The analysis of this flight is complicated by the frequent very large spikes
 in high-rate QCF that introduce a high level of noise in that spectrum.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Conclusion Regarding the Pitot-Static Sensor
\end_layout

\begin_layout Standard
A processing scheme was developed that duplicates the standard measurement
 of dynamic pressure at low frequency.
 At high frequency, there is significant reduction in the noise in the longitudi
nal component of the wind and in measured airspeed when the pitot-static
 sensor is used, but the variance spectra (esp.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VSpec2}
\end_layout

\end_inset

) still show evidence of high-frequency noise.
 I don't understand the remaining source of noise, which appears to be more
 than just random error in the transducer and varies in different flight
 situations.
 More study is needed to arrive at a method of calculating wind using this
 sensor, but it has provided a significant improvement.
\end_layout

\begin_layout Standard
The particular method used here is suited best to second-pass processing.
 A revision to the low-pass filter that uses a recursive filter could be
 implemented, but the effect of this (vs.
\begin_inset space ~
\end_inset

the centered filter used here) needs to be investigated.
\end_layout

\begin_layout Standard
The gust pod provides very useful measurements at 1 Hz, as documented in
 another note.
 The high-frequency spectrum from the gust pod was found in DEEPWAVE to
 be less subject to noise than the radome-based system, so investigating
 the high-rate behavior of that system is still a promising route to possible
 improvement in the wind measurements.
 The pitot-static tube has not solved the problem of noise in the high-rate
 variance spectra, although it provides a significant improvement.
\end_layout

\begin_layout Section
Using the Gust Pod in SOCRATES
\end_layout

\begin_layout Standard
Simple extension of the DEEPWAVE approach to the gust pod did not work well,
 so a different approach is developed in this note.
 The key problem arises from the gust-pod measurement of the relative wind,
 because the quantity needed is the relative wind with respect to the aircraft,
 not the gust pod.
 The gust pod is located in a region of distorted airflow where the sideslip
 and angle-of-attack components may affect each other, the pod is not oriented
 along the aircraft axis and may move relative to the fuselage.
 The wind is measured by combining the measurement of relative wind vector,
 transformed to a reference frame fixed relative to the Earth, with the
 measurement of the aircraft velocity vector.
 With the inclusion of the large pod in SOCRATES, the airflow distortion
 has become more problematic.
\end_layout

\begin_layout Subsection
The general approach
\end_layout

\begin_layout Standard
These steps are involved in the new processing scheme:
\end_layout

\begin_layout Enumerate
Find appropriate transformations of the gust-pod INS (CMIGITS) measurements
 of Earth-relative velocity to the reference frame of the aircraft (the
 a-frame).
 The INS incorporates updated to GPS measurements, and tests shown below
 give good agreement with the Honeywell-INS measurements.
 The differences in aircraft-velocity components between the two systems
 are typically quite small: For SOCRATEStf01, the mean difference between
 velocity components was 0.0005
\begin_inset Formula $\pm0.05$
\end_inset


\begin_inset space ~
\end_inset

m/s (sample standard deviation) for the easterly component and 
\begin_inset Formula $-0.0002\pm0.06$
\end_inset


\begin_inset space ~
\end_inset

m/s for the northerly component.
 Most of the listed sample standard deviation was contributed by periods
 when the roll angle was outside 
\begin_inset Formula $\pm3^{\circ}$
\end_inset

; within those limits, the sample standard deviation for 1-Hz measurements
 was about 0.025
\begin_inset space ~
\end_inset

m/s.
 Therefore, for the purpose of the present analysis, no transformation or
 correction to the CMIGITS-provided measurements of aircraft velocity will
 be used.
 The remaining need would be to compensate for the motion of the gust pod
 relative to the Honeywell INS.
 The gust pod is located 13 m behind the INS, 7 m to the port side, and
 within about 1 m vertically.
 However, the GPS antenna that the CMIGITS INS uses is at the same location
 as that used by standard wind processing, so the CMIGITS aircraft-velocity
 components are updated to that reference point.
 A remaining correction should address the motion of the gust-pod relative
 to the aircraft, which can be important when the attitude angles change
 or the pod moves relative to the aircraft, but this will be omitted here
 because it appears that the correction will be quite small.
 
\end_layout

\begin_layout Enumerate
The second transformation that will be needed is that of the attitude angles.
 Three reference frames are relevant here: the a-frame, defined with 
\begin_inset Formula $\hat{x}$
\end_inset

 forward along the longitudinal axis of the aircraft, 
\begin_inset Formula $\hat{y}$
\end_inset

 to starboard and perpendicular to 
\begin_inset Formula $\hat{x}$
\end_inset

, and 
\begin_inset Formula $\hat{z}$
\end_inset

 determined by the cross product of 
\begin_inset Formula $\hat{x}$
\end_inset

 and 
\begin_inset Formula $\hat{y}$
\end_inset

 but generally downward; the g-frame, defined analogously but with reference
 to the gust-pod orientation which is slightly different from the aircraft
 reference frame; and the l-frame, the local Earth-relative frame with 
\begin_inset Formula $\hat{x}$
\end_inset

 eastward, 
\begin_inset Formula $\hat{y}$
\end_inset

 northward, and 
\begin_inset Formula $\hat{z}$
\end_inset

 upward.
 Transformation among these reference frames were described in the Workflow
 Document for the Kalman Filter Technical Note.
 Because the CMIGITS IRU aligns with some residual error that is gradually
 corrected in flight by Kalman-filter updating, and because there is some
 motion of the wings in turbulence and as the aircraft fuel weight decreases,
 the difference in orientation between the two systems (Honeywell and CMIGITS)
 may change during the flight, so it is best to consider the attitude-angle
 transformation each time interval during processing rather than via a constant
 correction for the entire flight.
\end_layout

\begin_layout Enumerate
The crucial task for gust-pod processing is to determine the relative-wind
 components in the a-frame.
 In the g-frame, the relative wind that would be measured is distorted unaccepta
bly from the true relative wind outside the flow-distortion field of the
 aircraft, so the solution is not to simply transform the measured relative-wind
 vector from the g-frame to the l-frame.
 Instead, the approach can be as follows:
\end_layout

\begin_deeper
\begin_layout Enumerate
Consider the two differential-pressure measurements from the up-down and
 left-right pairs of ports on the gust pod to provide a measurement of the
 two components of the pressure difference at the gust pod.
 Make the trial assumption that the ports align with the axes defined by
 the CMIGITS INS\SpecialChar endofsentence
 Transform this pressure-gradient vector to the a-frame,
 where it is resolved into 
\begin_inset Formula $\hat{x}_{a}$
\end_inset

 and 
\begin_inset Formula $\hat{y}_{a}$
\end_inset

 components
\end_layout

\begin_layout Enumerate
Find the best representation of the a-frame relative wind (approximately
 {
\begin_inset Formula $V,\,V\beta,\,V\alpha$
\end_inset

} with 
\begin_inset Formula $V$
\end_inset

 the airspeed,
\begin_inset Formula $\beta$
\end_inset

 the sideslip angle and 
\begin_inset Formula $\alpha$
\end_inset

 the angle of attack) [XXX correct the signs] by a fit to the normal a-frame
 relative wind as a function of measurements like TASX and QCF or QC_GP
 and the transformed pressure-gradient components.
 This will give a relative-wind vector analogous to the one from the standard
 wind-sensing system but potentially independent of the radome pressure
 measurements that are sometimes affected by line freesing or contamination
 in the lines.
 This preserves the backup potential of the gust pod.
 
\end_layout

\begin_layout Enumerate
It is also desirable to produce an airspeed measurement from the gust pod
 (TASG) that is independent of the standard system, but it is probably best
 to use TASX to calculate the relative wind because it is less often affected
 by icing or line freezing than the radome ports and will normally provide
 the best available measurement of airspeed.
 The 
\begin_inset Quotes eld
\end_inset

PCOR
\begin_inset Quotes erd
\end_inset

 function used to adjust the airspeed measurement for the static defect
 depends on a valid measurement of angle of attack, but in a relatively
 insensitive way, and normal processing substitutes an average value when
 no valid measurement of AKRD is available.
 TASG might provide a valuable backup in that case.
\end_layout

\end_deeper
\begin_layout Standard
When the aircraft rolls about its longitudinal axis, complicated changes
 occur to the CMIGIT attitude angles.
 A pure roll change in the a-frame can change all three attitude angles
 in the g-frame because the gust-pod longitudinal axis is not aligned along
 the aircraft longitudinal axis.
 The angle transformations must account for this or the relative-wind measuremen
ts will not be valid for general orientations of the aircraft.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<get-data, include=FALSE, echo=FALSE, fig.cap=''>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "tf01"  ## for SOCRATES; ff01 for DEEPWAVE
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Project <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

Project <- "PREDICT"
\end_layout

\begin_layout Plain Layout

Project <- "SOCRATES"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", DataDirectory(), Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

# note that SOCRATES files use GGVSPD, have EWX, and have ADIF_GP and BDIF_GP
\end_layout

\begin_layout Plain Layout

VarNames <- c("VYC","GGALT","LATC", "LONC", "PSXC", "QCXC",
\end_layout

\begin_layout Plain Layout

              "WDC", "WSC", "GGVEW", "GGVNS", "VEW", "VNS",
\end_layout

\begin_layout Plain Layout

              "ADIFR", "ATTACK", "SSLIP", "PITCH", "TASX",
\end_layout

\begin_layout Plain Layout

              "ROLL", "THDG", "BDIFR", "GGVSPD", 'EWX',
\end_layout

\begin_layout Plain Layout

              "ADIF_GP", "BDIF_GP", "PS_GP", "QC_GP",
\end_layout

\begin_layout Plain Layout

              "CROLL_GP", "CPITCH_GP", "CTHDG_GP", "WIC",
\end_layout

\begin_layout Plain Layout

              "CVNS_GP", "CVEW_GP", "VSPD", "CVSPD_GP",
\end_layout

\begin_layout Plain Layout

              "ATX", 'SSRD', 'AKRD', 'QCF', 'PSF')
\end_layout

\begin_layout Plain Layout

D <- getNetCDF (fname, VarNames, Start=200000, End=223000) # high-rate data
 OK here
\end_layout

\begin_layout Plain Layout

## add some variables needed for the complementary-filter
\end_layout

\begin_layout Plain Layout

D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- 1
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

Data <- D
\end_layout

\begin_layout Plain Layout

Cradeg <- pi / 180.
\end_layout

\begin_layout Plain Layout

## this is the speed run from tf01:
\end_layout

\begin_layout Plain Layout

r5 <- setRange (Data, 221035, 221510)
\end_layout

\begin_layout Plain Layout

# r1 <- setRange (Data, 192609, 193328)
\end_layout

\begin_layout Plain Layout

# r2 <- setRange (Data, 195540, 200222)
\end_layout

\begin_layout Plain Layout

# r3 <- setRange (Data, 205058, 205604)
\end_layout

\begin_layout Plain Layout

# r4 <- setRange (Data, 210402, 211234)
\end_layout

\begin_layout Plain Layout

# Data2 <- Data[c(r1,r2,r3,r4),]
\end_layout

\begin_layout Plain Layout

Data2 <- Data[r5, ]
\end_layout

\begin_layout Plain Layout

Data2 <- Data2[abs(Data2$ROLL) < 3, ]
\end_layout

\begin_layout Plain Layout

r6 <- setRange(Data, 221600, 221830)
\end_layout

\begin_layout Plain Layout

Data3 <- Data[r6, ]
\end_layout

\begin_layout Plain Layout

capnFaoaG <- "For the gust pod, the angle-of-attack determined from the
 fit as a function of the reference angle provided by (
\backslash

\backslash
ref{eq:AOAeq}), for the speed run on SOCRATES tf01.
 The dashed orange line is the fit to the measurements, and the thinner
 solid black line is the result from the coefficients determined in DEEPWAVE."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Details of the Transformation
\end_layout

\begin_layout Standard
The vector to be transformed has components (0, BDIF_GP, ADIF_GP) in the
 g-frame.
 Because in the R package 
\begin_inset Quotes eld
\end_inset

Ranadu
\begin_inset Quotes erd
\end_inset

 [
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/WilliamCooper/Ranadu.git"

\end_inset

] there is a transformation function (XformLA) that transforms from the
 a-frame to the l-frame or the l-frame to the a-frame, that will be used
 here because that transformation function was tested extensively during
 the development of the Kalman filter.
 Details are described in the workflow document
\begin_inset CommandInset href
LatexCommand href
name "workflow document"
target "https://github.com/WilliamCooper/KalmanFilter/blob/master/WorkflowKalmanFilter.pdf"

\end_inset

 for the Kalman filter Technical Note (
\begin_inset CommandInset citation
LatexCommand cite
key "Cooper2017ncartn"

\end_inset

).
 The procedure is to transform the pressure vector from the g-frame to the
 l-frame using the CMIGITS-provided attitude angles, then transform from
 the l-frame to the a-frame using the Honeywell-provided attitude angles
 and the inverse function in XformLA().
 The code listed below produces, in diffPa, the matrix of measured pressure
 differences transformed to the a-frame:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<xform, echo=TRUE, include=TRUE, fig.cap=''>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

diffP <- c(rep(0, nrow(Data)), Data$BDIF_GP, Data$ADIF_GP)  ## check signs!!
\end_layout

\begin_layout Plain Layout

dim(diffP) <- c(nrow(Data), 3)
\end_layout

\begin_layout Plain Layout

DF <- data.frame(ROLL=Data$CROLL_GP, PITCH=Data$CPITCH_GP, THDG=Data$CTHDG_GP)
\end_layout

\begin_layout Plain Layout

diffPl <- Ranadu::XformLA (DF, diffP)  ## DF contains gustpod attitude angles
\end_layout

\begin_layout Plain Layout

diffPa <- Ranadu::XformLA (Data, diffPl, .inverse=TRUE)  # pressure vector
 in a-frame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<akfit, echo=FALSE, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$AK <- cff * Data$QRF + cfs[1] + cfs[2] * Data$QRS + cfs[3] * Data$QCFS
\end_layout

\begin_layout Plain Layout

Data$DIFFPX <- diffPa[,1]
\end_layout

\begin_layout Plain Layout

Data$DIFFPY <- diffPa[,2]
\end_layout

\begin_layout Plain Layout

Data$DIFFPZ <- diffPa[,3]
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(Data$PS_GP, Data$QC_GP)
\end_layout

\begin_layout Plain Layout

#SummarizeFit (lm(AKRD ~ I(DIFFPZ/QC_GP) + I((DIFFPZ/QC_GP)^2) + 
\end_layout

\begin_layout Plain Layout

#                 I(DIFFPZ/QC_GP*MACHG)+ I(DIFFPY/QC_GP), data=Data))
\end_layout

\begin_layout Plain Layout

sig1 <- summary(lm(AK ~ I(DIFFPZ/QC_GP), data=Data))$sigma
\end_layout

\begin_layout Plain Layout

# sig2 <- summary(lm(AKRD ~ I(DIFFPZ/QC_GP) + I((DIFFPZ/QC_GP)^2), data=Data))$s
igma
\end_layout

\begin_layout Plain Layout

sig2 <- summary(lm(AK ~ I(DIFFPZ/QC_GP)  + I(DIFFPZ/QC_GP*MACHG), data=Data))$si
gma
\end_layout

\begin_layout Plain Layout

sig3 <- summary(lm(AK ~ I(DIFFPZ/QC_GP) + I(DIFFPZ/QC_GP*MACHG)+ I(DIFFPY/QC_GP)
, data=Data))$sigma
\end_layout

\begin_layout Plain Layout

sig4 <- summary(lm(AK ~ I(DIFFPZ/QC_GP) + I((DIFFPZ/QC_GP)^2) + I(DIFFPZ/QC_GP*M
ACHG)+ I(DIFFPY/QC_GP), data=Data))$sigma
\end_layout

\begin_layout Plain Layout

cga <- coef (lm(AK ~ I(DIFFPZ/QC_GP) + I((DIFFPZ/QC_GP)^2) + I(DIFFPZ/QC_GP*MACH
G)+ I(DIFFPY/QC_GP), data=Data))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Empirical Coefficients
\end_layout

\begin_layout Subsubsection
Angle of Attack
\begin_inset CommandInset label
LatexCommand label
name "subsec:Calibration-AOA"

\end_inset


\end_layout

\begin_layout Standard
The standard method of calibrating the measurement of angle-of-attack is
 described in detail my 
\begin_inset CommandInset citation
LatexCommand cite
key "Cooper2016ncartn"

\end_inset

.
 Here it is assumed that this has already produced valid angle-of-attack
 measurements for the radome, in the variable AKRD.
 The goal then is to find an empirical equation that duplicates AKRD but
 uses measurements from the gust-pod.
 Because of flow distortion at the gust-pod, it is expected that the empirical
 relationship will be more complicated and will involve the horizontal as
 well as vertical pressure differences from the gust-pod.
 In addition, the data used for the fit should include various maneuvers
 in addition to the speed runs normally used for finding a representation
 of AKRD.
\end_layout

\begin_layout Standard
SOCRATES test flight 1 included a complete set of maneuvers, so that entire
 flight will be used to determine the empirical representation of angle
 of attack.
 The new variable will be called AK_GP and will be determined by linear
 fits to variables from the gust-pod after transformation to the a-frame.
 The following table shows the residual standard error of the fit for some
 choices of the empirical equation.
 The variables used are: 
\begin_inset Formula $\Delta p_{z}$
\end_inset

 is the pressure difference between top-and-bottom pressure ports on the
 gust-pod after transformation to the a-frame; 
\begin_inset Formula $\Delta p_{y}$
\end_inset

 is the corresponding difference between the starboard and port-side pressure
 ports; 
\begin_inset Formula $q_{c}$
\end_inset

 is the dynamic pressure measured at the forward port on the gust-pod; and
 
\begin_inset Formula $M_{g}$
\end_inset

 the Mach number calculated using the uncorrected measurements QC_GP and
 PS_GP from the gust pod.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Equation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
residual standard deviation [
\begin_inset Formula $^{\circ}$
\end_inset

]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{0}+a_{1}\frac{\Delta p_{z}}{q_{g}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sig1,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $"\,+a_{2}M_{g}\frac{\Delta p_{z}}{q_{g}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sig2, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $"\,+a_{3}\frac{\Delta p_{y}}{q_{g}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sig3, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $"\,+a_{4}\left(\frac{\Delta p_{z}}{q_{g}}\right)^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sig4, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<akplot1, echo=FALSE, include=TRUE, fig.height=5, fig.cap='Comparison of
 gust-pod fit result (AK
\backslash

\backslash
_GP) to the complementary-filter radome-based value for angle of attack
 (AK), for SOCRATES test flight 1.
 Also shown as the red line is the difference multiplied by 5 to make the
 difference easier to interpret.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$AK_GP <- with(Data, cga[1] + cga[2] * DIFFPZ / QC_GP + cga[3] * (DIFFPZ
 / QC_GP)^2 + cga[4] * DIFFPZ/QC_GP*MACHG + cga[5] * DIFFPY/QC_GP)
\end_layout

\begin_layout Plain Layout

with(Data, plotWAC(data.frame(Time, AK, AK_GP, 5*(AK-AK_GP)), legend.position='top
left'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<akplot2, echo=FALSE, include=TRUE, fig.height=4, fig.cap='As in the preceding
 plot but expanded to show only the period of the speed run and without
 factor-of-five magnification of the difference (red line).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

with(Data[setRange (Data, 221035, 221510),], plotWAC(data.frame(Time, AK,
 AK_GP, (AK-AK_GP)), legend.position='topright'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting fit has residual standard deviation comparable to that obtained
 in typical calibrations leading to AKRD, and as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:akplot1}
\end_layout

\end_inset

 the five-coefficient fit provides a very good representation of AKRD.
 Figure.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:akplot2}
\end_layout

\end_inset

 shows an expanded view of the period of the speed run.
 The difference at large angle-of-attack (near 5
\begin_inset Formula $^{\circ}$
\end_inset

) is a little larger than elsewhere, but values of the angle-of-attack this
 large are seldom encountered except during maneuvers like this.
\end_layout

\begin_layout Subsubsection
Sideslip
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ss-gp, include=TRUE, echo=FALSE, fig.cap='Comparison of SS
\backslash

\backslash
_GP, calculated using the new SOCRATES coefficients, to SSRD from the radome,
 for the yaw maneuver from SOCRATES tf01.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sig1s <- summary(lm(SSRD ~ I(DIFFPY/QC_GP), data=Data))$sigma
\end_layout

\begin_layout Plain Layout

# sig2 <- summary(lm(AKRD ~ I(DIFFPZ/QC_GP) + I((DIFFPZ/QC_GP)^2), data=Data))$s
igma
\end_layout

\begin_layout Plain Layout

sig2s <- summary(lm(SSRD ~ I(DIFFPY/QC_GP)  + I(DIFFPY/QC_GP*MACHG), data=Data))
$sigma
\end_layout

\begin_layout Plain Layout

sig3s <- summary(lm(SSRD ~ I(DIFFPY/QC_GP) + I(DIFFPY/QC_GP*MACHG)+ I(DIFFPZ/QC_
GP), data=Data))$sigma
\end_layout

\begin_layout Plain Layout

cgs <- coef(lm(SSRD ~ I(DIFFPY/QC_GP) + I(DIFFPY/QC_GP*MACHG)+ I(DIFFPZ/QC_GP),
 data=Data))
\end_layout

\begin_layout Plain Layout

sig4s <- summary(lm(SSRD ~ I(DIFFPY/QC_GP) + I((DIFFPY/QC_GP)^2) + I(DIFFPY/QC_G
P*MACHG)+ I(DIFFPZ/QC_GP), data=Data))$sigma
\end_layout

\begin_layout Plain Layout

cgs <- coef (lm(SSRD ~ I(DIFFPY/QC_GP)  + I(DIFFPY/QC_GP*MACHG)+ I(DIFFPZ/QC_GP)
, data=Data))
\end_layout

\begin_layout Plain Layout

Data3$SS_GPDW <- -3.621 + 12.184 * (Data3$BDIF_GP / Data3$QC_GP) 
\end_layout

\begin_layout Plain Layout

fa <- lm(SSRD ~ I(BDIF_GP / QC_GP), data=Data3) 
\end_layout

\begin_layout Plain Layout

cfa <- coef(fa) 
\end_layout

\begin_layout Plain Layout

Data3$SS_GP <- cfa[1] + cfa[2] * Data3$BDIF_GP / Data3$QC_GP 
\end_layout

\begin_layout Plain Layout

Data$SS_GP <- cgs[1] + cgs[2] * Data$DIFFPY/Data$QC_GP + cgs[3] * Data$DIFFPY/Da
ta$QC_GP*Data$MACHG + cgs[4] * Data$DIFFPZ/Data$QC_GP
\end_layout

\begin_layout Plain Layout

Data3 <- Data[r6, ]
\end_layout

\begin_layout Plain Layout

with(Data3, plotWAC (data.frame (SSRD, SS_GP), xlab='SSRD', type='p', pch=20,
 xlim=c(-2,2), ylim=c(-2,2))) 
\end_layout

\begin_layout Plain Layout

# with(Data3, points (SSRD, SS_GPDW, pch=20, col='red')) 
\end_layout

\begin_layout Plain Layout

lines(c(-5,5), c(-5,5), col='darkorange', lty=2, lwd=2) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sideslip is handled in a similar manner, but without the complementary-filter
 basis used for angle-of-attack because there does not appear to be a varying
 offset to the sideslip angle.
 Some exploration of possible variables to include in an empirical representatio
n led to this equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\beta=e_{0}+\frac{\Delta p_{y}}{q_{g}}\left(e_{0}+e_{1}M_{g}\right)+e_{2}\frac{\Delta p_{z}}{q_{g}}\label{eq:newSSG}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The residual standard deviation was 
\begin_inset Formula $0.07^{\circ}$
\end_inset

 for the entire flight (SOCRATEStf01).
 The yaw maneuver from SOCRATES tf01 (22:16:00â€“22:18:30) is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ss-gp}
\end_layout

\end_inset

.
 The yaw maneuver suggests a small revision: add 
\begin_inset Formula $0.03^{\circ}$
\end_inset

 to the SS_GP values and then multiply by 0.94.
 This is a minor adjustment, so for now the coefficients determined from
 the entire flight will be used.
 This may need adjustment when more data from SOCRATES become available.
\end_layout

\begin_layout Subsubsection
Airspeed
\end_layout

\begin_layout Standard
The equation developed in Cooper et al.
\begin_inset space ~
\end_inset

(2016) for airspeed was based on this fit to the ratio 
\begin_inset Formula $q/p$
\end_inset

 as measured by the standard system:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{q}{p}=d_{0}+d_{1}\frac{q_{g}}{p_{g}}+d_{2}M_{g}\frac{q_{g}}{p_{q}}+d_{3}\left(\frac{q_{g}}{p_{g}}\right)^{2}+d_{4}\frac{\Delta p_{\alpha,g}}{q_{g}}+d_{5}M_{g}+d_{6}\left(\frac{\Delta p_{\alpha,g}}{q_{g}}\right)^{2}+d_{7}M_{g}\frac{\Delta p_{\alpha,g}}{q_{g}}\label{eq:TASG}
\end{equation}

\end_inset

where 
\begin_inset Formula $q$
\end_inset

 is dynamic pressure, 
\begin_inset Formula $p$
\end_inset

 is ambient pressure, 
\begin_inset Formula $M_{g}$
\end_inset

 is the Mach number determined from the gust-pod measurements of dynamic
 and ambient pressure (
\begin_inset Formula $q_{g}$
\end_inset

 and 
\begin_inset Formula $p_{g}$
\end_inset

), and 
\begin_inset Formula $\Delta p_{\alpha,g}$
\end_inset

 is the pressure difference between top and bottom pressure ports on the
 gust-pod.
 The DEEPWAVE fit found coefficients {
\begin_inset Formula $d_{i}$
\end_inset

}={1.1940, 27.2893, 
\begin_inset Formula $-29.0483$
\end_inset

, 13.6231, 
\begin_inset Formula $-0.5936$
\end_inset

, 
\begin_inset Formula $-7.5812$
\end_inset

, 0.1554, 1.2607}.
 Repeating the fit for the speed-run data gave coefficients as listed below
 and resulting predictions for 
\begin_inset Formula $q/p$
\end_inset

 as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tasg}
\end_layout

\end_inset

.
 While the fit is very good, it is significantly different from that found
 in DEEPWAVE, as shown by the black dots in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tasg}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tasg, include=TRUE, echo=FALSE, fig.height=4, fig.width=4, fig.cap='Predicted
 ratio q/p from gust-pod measurements vs that measured by the standard wind-sens
ing system, for the speed run in SOCRATES test flight tf01.
 The black dots show the measurements that would be obtained using the coefficie
nts determined for DEEPWAVE.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data2$QR <- Data2$QCXC / Data2$PSXC
\end_layout

\begin_layout Plain Layout

Data2$QRG <- Data2$QC_GP / Data2$PS_GP
\end_layout

\begin_layout Plain Layout

Data2$MACHG <- MachNumber(Data2$PS_GP, Data2$QC_GP)
\end_layout

\begin_layout Plain Layout

Data2$ARG <- Data2$ADIF_GP / Data2$QC_GP
\end_layout

\begin_layout Plain Layout

fmt <- lm (QR ~ QRG + I(MACHG  * QRG) + I(QRG^2) + ARG + MACHG + I(ARG^2)
 + I(MACHG*ARG), data=Data2)
\end_layout

\begin_layout Plain Layout

cft <- coefficients(fmt)
\end_layout

\begin_layout Plain Layout

Data2$QRP <- with(Data2, cft[1]+cft[2]*QRG+cft[3]*MACHG*QRG+cft[4]*QRG^2+cft[5]*
ARG+cft[6]*MACHG+
\end_layout

\begin_layout Plain Layout

                         cft[7]*ARG^2+cft[8]*MACHG*ARG)
\end_layout

\begin_layout Plain Layout

with(Data2, plotWAC (data.frame(QR, QRP), xlab='standard q/p', ylab='predicted
 q/p', 
\end_layout

\begin_layout Plain Layout

                     type='p', pch=20, col='blue'))
\end_layout

\begin_layout Plain Layout

title('SOCRATES tf01 speed run only')
\end_layout

\begin_layout Plain Layout

lines(c(0,1), c(0,1), col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

cfdw <- c(1.1940, 27.2893, -29.0483, 13.6231, -0.5936, -7.5812, 0.1554, 1.2607)
\end_layout

\begin_layout Plain Layout

Data2$QRPD <- with(Data2, cfdw[1]+cfdw[2]*QRG+cfdw[3]*MACHG*QRG+cfdw[4]*QRG^2+cf
dw[5]*ARG+cfdw[6]*MACHG+
\end_layout

\begin_layout Plain Layout

                         cfdw[7]*ARG^2+cfdw[8]*MACHG*ARG)
\end_layout

\begin_layout Plain Layout

with(Data2, points (data.frame(QR, QRPD), pch=20, col='black'))
\end_layout

\begin_layout Plain Layout

# lines(c(0,1), c(0,1), col='darkgreen', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fitTASG, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SummarizeFit (fmt)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Examples of Results
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<newWind, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## previously calculated AK_GP, SS_GP, AK
\end_layout

\begin_layout Plain Layout

## for wind calculation, use TASX -- normally OK
\end_layout

\begin_layout Plain Layout

## but include TASG also:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$QR <- Data$QCXC / Data$PSXC
\end_layout

\begin_layout Plain Layout

Data$QRG <- Data$QC_GP / Data$PS_GP
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(Data$PS_GP, Data$QC_GP)
\end_layout

\begin_layout Plain Layout

Data$ARG <- Data$ADIF_GP / Data$QC_GP
\end_layout

\begin_layout Plain Layout

Data$QRP <- with(Data, cft[1]+cft[2]*QRG+cft[3]*MACHG*QRG+cft[4]*QRG^2+cft[5]*AR
G+cft[6]*MACHG+
\end_layout

\begin_layout Plain Layout

                         cft[7]*ARG^2+cft[8]*MACHG*ARG)
\end_layout

\begin_layout Plain Layout

## replace MACHG with new value:
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(1, Data$QRP)
\end_layout

\begin_layout Plain Layout

Data$TASG <- TrueAirspeed(Data$MACHG, Data$ATX)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DataW <- Data
\end_layout

\begin_layout Plain Layout

DataW$ATTACK <- Data$AK_GP
\end_layout

\begin_layout Plain Layout

DataW$SSLIP <- Data$SS_GP
\end_layout

\begin_layout Plain Layout

DataW$VEW <- Data$CVEW_GP
\end_layout

\begin_layout Plain Layout

DataW$VNS <- Data$CVNS_GP
\end_layout

\begin_layout Plain Layout

DataW$GGVSPD <- Data$CVSPD_GP
\end_layout

\begin_layout Plain Layout

DataN <- WindProcessor (DataW)
\end_layout

\begin_layout Plain Layout

Data$WIG <- DataN$WIN
\end_layout

\begin_layout Plain Layout

Data$WSG <- DataN$WSN
\end_layout

\begin_layout Plain Layout

Data$WDG <- DataN$WDN
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfplots1, include=TRUE, fig.cap='Comparison of angles of attack from the
 standard calculation (AKRD), the complementary-filter solution for the
 radome (AK), and the measurement from the gust pod (AK
\backslash

\backslash
_GP).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

with(Data, plotWAC(data.frame(Time, AKRD, AK, AK_GP), lwd=c(2,2,1), lty=c(1,1,4),
 legend.position='topleft'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfplots2, include=TRUE, fig.cap='Comparison of sideslip angles from the
 standard calculation (SSRD) and from the gust pod (SS
\backslash

\backslash
_GP).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

with(Data, plotWAC(data.frame(Time, SSRD, SS_GP), legend.position='topleft'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfplots3, include=TRUE, fig.cap='Comparison of measurements of the vertical
 wind from the standard calculation (WIC) and from the gust pod (WIG).
 Also shown in the result from the complementary-filter solution applied
 to the radome system (WIN).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DataW <- Data
\end_layout

\begin_layout Plain Layout

DataW$ATTACK <- Data$AK
\end_layout

\begin_layout Plain Layout

DataN <- WindProcessor (DataW)
\end_layout

\begin_layout Plain Layout

Data$WIY <- DataN$WIN 
\end_layout

\begin_layout Plain Layout

with(Data, plotWAC(data.frame(Time, WIC, WIY, WIG), lwd=c(2,2,1), lty=c(1,1,4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfplots4, include=TRUE, fig.cap='Comparison of measurements of the horizontal
 wind from the standard calculation (WDC amd WSC) and from the gust pod
 (WDG and WSG).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1, heights = c(5,6)) 
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1) + 0.1)
\end_layout

\begin_layout Plain Layout

with(Data, plotWAC(data.frame(Time, WDC, WDG)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1) + 0.1)
\end_layout

\begin_layout Plain Layout

with(Data, plotWAC(data.frame(Time, WSC, WSG), legend.position='topright'))
\end_layout

\begin_layout Plain Layout

layout(matrix(1:1, ncol = 1), widths = 1, heights = c(6)) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This processing recommended in the final section of this report was applied
 to SOCRATES test flight #1 so that the gust-pod measurements of wind can
 be compared to the standard wind measurements based on the radome.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfplots1}
\end_layout

\end_inset

 shows that the angle of attack provided by the gust pod provide almost
 the same value as the complementary-filter result from the radome, but
 both are offset significantly from the standard-processing value (AKRD).
 A similar comparison is shown for sideslip in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfplots2}
\end_layout

\end_inset

.
 While the agreement is mostly good, there is some clear underestimation
 of the magnitude of the sideslip in the circle maneuvers that occur from
 about 22:00â€“22:15.
 This suggests that the sideslip measurement from the gust-pod may not be
 adequate in turns, as perhaps might be expected because the effects of
 flow distortion are exaggerated in this nose-up banked configuration.
 The vertical wind calculations are compared in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfplots3}
\end_layout

\end_inset

 and the horizontal wind in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfplots4}
\end_layout

\end_inset

.
 These plots show that the wind measurements from the gust pod, entirely
 independent of variables provided by the radome, provide a valid measurement
 of the wind that is in reasonable agreement with the standard system.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection

\emph on
Summary
\begin_inset Note Note
status open

\begin_layout Plain Layout

\emph on
keep this short - 1/2 page or less
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:Summary"

\end_inset


\end_layout

\begin_layout Standard
Use these equations and coefficients to find the relative-flow angles and
 ratio of dynamic to ambient pressure (with MACHGG, different from MACHG
 defined below, defined as the Mach number calculated from QC_GP and PS_GP).
 The variables DIFFPY and DIFFPZ are defined earlier as the pressure-difference
 components measured by the gust pod and then transformed to the a-frame.
 These definitions are also used: ARG=ADIF_GP/QC_GP, and QRG=QC_GP/PS_GP):
 Because of the complexity of the coordinate transformations, it seems preferabl
e to add these variables in second-pass processing.
 That is also a convenient way to add the complementary-filter result for
 AKRD and WIC (here, AK and WIY).
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
AK_GP: 
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cga[1],digits=5,nsmall=4)}
\end_layout

\end_inset

 + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cga[2],digits=5,nsmall=4)}
\end_layout

\end_inset

 * DIFFPZ / QC_GP + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cga[3],digits=5,nsmall=4)}
\end_layout

\end_inset

 * (DIFFPZ / QC_GP)^2 + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cga[4],digits=5,nsmall=4)}
\end_layout

\end_inset

 * DIFFPZ/QC_GP*MACHGG + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cga[5],digits=5,nsmall=4)}
\end_layout

\end_inset

 * DIFFPY/QC_GP
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
SS_GP: 
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cgs[1], 5)}
\end_layout

\end_inset

 + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cgs[2], 5)}
\end_layout

\end_inset

 * DIFFPY / QC_GP +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cgs[3], 5)}
\end_layout

\end_inset

 * DIFFPY / QC_GP * MACHGG + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cgs[4], 5)}
\end_layout

\end_inset

 * DIFFPZ / QC_GP
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
QP_GP: 
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cft[1], digits=5, nsmall=4)}
\end_layout

\end_inset

 + QRG * (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cft[2], 5)}
\end_layout

\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cft[3], 5)}
\end_layout

\end_inset

 * MACHGG + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cft[4], 5)}
\end_layout

\end_inset

 * QRG)
\begin_inset Newline newline
\end_inset

+ ARG * (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cft[5], 5)}
\end_layout

\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cft[7], 5)}
\end_layout

\end_inset

 * ARG 
\begin_inset space ~
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cft[8], 5)}
\end_layout

\end_inset

 * MACHGG)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cft[6], 5)}
\end_layout

\end_inset

 * MACHGG
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
MACHG:
\series default
 Calculate from QP_GP: 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathrm{MACHG}=\sqrt{\frac{c_{v}}{R_{a}}((1+\mathrm{QP\_GP})^{R_{a}/c_{p}}-1)}
\]

\end_inset

where 
\begin_inset Formula $c_{p},\,c_{v},\,R_{a}$
\end_inset

 are respectively the specific heat at constant pressure, specific heat
 at constant volume, and gas constant for air.
 The appropriate respective values for dry air are {1004.728, 717.6631, 287.07}.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
TASG: 
\series default
Calculate from MACHG and ATX (optionally with humidity correction, here
 and in the calculation of MACHG).
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
Wind:
\series default
 Calculate using gust() but with TASG, CVEW_GP, CVNS_GP, CVSPD_GP, CPITCH_GP,
 CROLL_GP, CTHDG_GP, AK_GP, and SS_GP used in place of the usual variables
 from the standard wind system.
 This gives a wind measurement that is not dependent on any information
 from the standard system except temperature.
\end_layout

\begin_layout Section
The Processor
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<newVarCalc>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- 'SOCRATES'
\end_layout

\begin_layout Plain Layout

Flight <- 2
\end_layout

\begin_layout Plain Layout

fname <- sprintf ('%s%s/%srf%02d.nc', DataDirectory(), Project, Project,
 Flight)
\end_layout

\begin_layout Plain Layout

fnew <- sub ('.nc', 'Y.nc', fname)
\end_layout

\begin_layout Plain Layout

Z <- file.copy (fname, fnew, overwrite=TRUE)  ## BEWARE: overwrites without
 warning!!
\end_layout

\begin_layout Plain Layout

## read variables needed for the calculation
\end_layout

\begin_layout Plain Layout

FI <- DataFileInfo (fname)
\end_layout

\begin_layout Plain Layout

VarList <- unique(c(VarNames, 'TASX', 'ATTACK', 'SSLIP', 'GGVEW', 'GGVNS',
 'VEW', 'VNS', 'THDG', 'ROLL', 'PITCH', 'LAT', 'LON', 'VSPD', 'PSXC', 'GGLAT',
 'GGALT', 'ACINS'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (!('GGVSPD' %in% FI$Variables)) {
\end_layout

\begin_layout Plain Layout

  if ('GGVSPDB' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

    VarList [which (VarList == 'GGVSPD')] <- 'GGVSPDB'
\end_layout

\begin_layout Plain Layout

  } else if ('VSPD_A' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

    VarList [which (VarList == 'GGVSPD')] <- 'VSPD_A'
\end_layout

\begin_layout Plain Layout

  } else if ('VSPD_G' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

    VarList [which (VarList == 'GGVSPD')] <- 'VSPD_G'
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    print ('ERROR: no VSPD variable found')
\end_layout

\begin_layout Plain Layout

    exit()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (Var in VarList) {
\end_layout

\begin_layout Plain Layout

  if (!(Var %in% FI$Variables)) {
\end_layout

\begin_layout Plain Layout

    print (sprintf (' required variable %s not found in file %s; skipping...',
 Var, fname))
\end_layout

\begin_layout Plain Layout

    exit()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- getNetCDF(fname, VarList)
\end_layout

\begin_layout Plain Layout

## ROC.R -- chunk to add ROC variable
\end_layout

\begin_layout Plain Layout

## needs: data.frame Data containing netCDF variables PSXC, GGLAT, GGALT,
 ACINS, Grav
\end_layout

\begin_layout Plain Layout

## also assumes Rate is set
\end_layout

\begin_layout Plain Layout

D$Grav <- Gravity(D$GGLAT, D$GGALT)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DPDT <- c(0, diff(D$PSXC)) * Rate
\end_layout

\begin_layout Plain Layout

g <- D$Grav
\end_layout

\begin_layout Plain Layout

g[is.na(g)] <- 9.80
\end_layout

\begin_layout Plain Layout

WPPRIME <- -StandardConstant('Rd') * (273.15 + D$ATX) /
\end_layout

\begin_layout Plain Layout

              (D$PSXC * g) * DPDT
\end_layout

\begin_layout Plain Layout

ACINS <- zoo::na.approx (as.vector(D$ACINS), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

ACINS[is.na(ACINS)] <- 0
\end_layout

\begin_layout Plain Layout

WPSTAR <- cumsum(ACINS)
\end_layout

\begin_layout Plain Layout

DIF <- WPPRIME - WPSTAR
\end_layout

\begin_layout Plain Layout

DIF <- zoo::na.approx (as.vector(DIF), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

DIF[is.na(DIF)] <- 0
\end_layout

\begin_layout Plain Layout

tau <- 300 * Rate
\end_layout

\begin_layout Plain Layout

DIF <- signal::filtfilt (signal::butter (3, 2/tau), DIF)
\end_layout

\begin_layout Plain Layout

D$ROC <- WPSTAR + DIF
\end_layout

\begin_layout Plain Layout

D$ZROC <- D$GGALT[1] + cumsum (D$ROC)
\end_layout

\begin_layout Plain Layout

rm (DPDT, g, WPPRIME, WPSTAR, DIF)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- DataFileInfo(fname, LLrange=FALSE)$Rate
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

Data <- D
\end_layout

\begin_layout Plain Layout

Cradeg <- pi / 180.
\end_layout

\begin_layout Plain Layout

diffP <- c(rep(0, nrow(Data)), Data$BDIF_GP, Data$ADIF_GP)  ## check signs!!
\end_layout

\begin_layout Plain Layout

dim(diffP) <- c(nrow(Data), 3)
\end_layout

\begin_layout Plain Layout

DF <- data.frame(ROLL=Data$CROLL_GP, PITCH=Data$CPITCH_GP, THDG=Data$CTHDG_GP)
\end_layout

\begin_layout Plain Layout

diffPl <- Ranadu::XformLA (DF, diffP)  ## DF contains gustpod attitude angles
\end_layout

\begin_layout Plain Layout

diffPa <- Ranadu::XformLA (Data, diffPl, .inverse=TRUE)  # pressure vector
 in a-frame
\end_layout

\begin_layout Plain Layout

Data$AKY <- cff * Data$QRF + cfs[1] + cfs[2] * Data$QRS + cfs[3] * Data$QCFS
\end_layout

\begin_layout Plain Layout

Data$DIFFPX <- diffPa[,1]
\end_layout

\begin_layout Plain Layout

Data$DIFFPY <- diffPa[,2]
\end_layout

\begin_layout Plain Layout

Data$DIFFPZ <- diffPa[,3]
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(Data$PS_GP, Data$QC_GP)
\end_layout

\begin_layout Plain Layout

Data$AK_GP <- with(Data, cga[1] + cga[2] * DIFFPZ / QC_GP + 
\end_layout

\begin_layout Plain Layout

             cga[3] * (DIFFPZ / QC_GP)^2 + 
\end_layout

\begin_layout Plain Layout

             cga[4] * DIFFPZ/QC_GP*MACHG + cga[5] * DIFFPY/QC_GP)
\end_layout

\begin_layout Plain Layout

Data$SS_GP <- cgs[1] + cgs[2] * Data$DIFFPY/Data$QC_GP + 
\end_layout

\begin_layout Plain Layout

              cgs[3] * Data$DIFFPY/Data$QC_GP*Data$MACHG + 
\end_layout

\begin_layout Plain Layout

              cgs[4] * Data$DIFFPZ/Data$QC_GP
\end_layout

\begin_layout Plain Layout

Data$QRG <- Data$QC_GP / Data$PS_GP
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(Data$PS_GP, Data$QC_GP)
\end_layout

\begin_layout Plain Layout

Data$ARG <- Data$ADIF_GP / Data$QC_GP
\end_layout

\begin_layout Plain Layout

Data$QRP <- with(Data, cft[1] + cft[2] * QRG +
\end_layout

\begin_layout Plain Layout

            cft[3] * MACHG * QRG + cft[4] * QRG^2 + cft[5] * ARG +
\end_layout

\begin_layout Plain Layout

            cft[6] * MACHG + cft[7] * ARG^2 + cft[8] * MACHG * ARG)
\end_layout

\begin_layout Plain Layout

## replace MACHG with new value:
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(1, Data$QRP)
\end_layout

\begin_layout Plain Layout

Data$TASG <- TrueAirspeed(Data$MACHG, Data$ATX)
\end_layout

\begin_layout Plain Layout

DataW <- Data
\end_layout

\begin_layout Plain Layout

DataW$ATTACK <- Data$AKY
\end_layout

\begin_layout Plain Layout

DataN <- WindProcessor (DataW)
\end_layout

\begin_layout Plain Layout

Data$WIY <- DataN$WIN
\end_layout

\begin_layout Plain Layout

DataW <- Data
\end_layout

\begin_layout Plain Layout

DataW$ATTACK <- Data$AK_GP
\end_layout

\begin_layout Plain Layout

DataW$SSLIP <- Data$SS_GP
\end_layout

\begin_layout Plain Layout

DataW$VEW <- Data$CVEW_GP
\end_layout

\begin_layout Plain Layout

DataW$VNS <- Data$CVNS_GP
\end_layout

\begin_layout Plain Layout

DataW$GGVSPD <- Data$CVSPD_GP
\end_layout

\begin_layout Plain Layout

DataN <- WindProcessor (DataW, CompF=FALSE)  ## suppress comp filter and
 GPS lever
\end_layout

\begin_layout Plain Layout

Data$WIG <- DataN$WIN
\end_layout

\begin_layout Plain Layout

Data$WSG <- DataN$WSN
\end_layout

\begin_layout Plain Layout

Data$WDG <- DataN$WDN
\end_layout

\begin_layout Plain Layout

hdg <- Data$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

wd <- Data$WDG * Cradeg + pi
\end_layout

\begin_layout Plain Layout

Data$UXG <- Data$WSG * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd))
\end_layout

\begin_layout Plain Layout

hdg <- hdg - pi/2
\end_layout

\begin_layout Plain Layout

Data$VYG <- Data$WSG * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd))
\end_layout

\begin_layout Plain Layout

## now have all new variables
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<newNetCDF>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# function to copy attributes 
\end_layout

\begin_layout Plain Layout

copy_attributes <- function (atv, v, nfile) {
\end_layout

\begin_layout Plain Layout

  for (i in 1:length(atv)) {
\end_layout

\begin_layout Plain Layout

    aname <- names(atv[i])
\end_layout

\begin_layout Plain Layout

    if (grepl ('name', aname)) {next}  # skips long and standard names
\end_layout

\begin_layout Plain Layout

    if (grepl ('units', aname)) {next}
\end_layout

\begin_layout Plain Layout

    if (grepl ('Dependencies', aname)) {next}
\end_layout

\begin_layout Plain Layout

    if (grepl ('actual_range', aname)) {next}
\end_layout

\begin_layout Plain Layout

    if (is.numeric (atv[[i]])) {
\end_layout

\begin_layout Plain Layout

      ncatt_put (nfile, v, attname=aname, attval=as.numeric(atv[[i]]))
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      ncatt_put (nfile, v, attname=aname, attval=as.character (atv[[i]]))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

netCDFfile <- nc_open (fnew, write=TRUE) 
\end_layout

\begin_layout Plain Layout

Dimensions <- attr (Data, "Dimensions")
\end_layout

\begin_layout Plain Layout

Dim <- Dimensions[["Time"]]
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

if ("sps25" %in% names (Dimensions)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

  Dim <- list(Dimensions[["sps25"]], Dimensions[["Time"]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

if ("sps50" %in% names (Dimensions)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 50
\end_layout

\begin_layout Plain Layout

  Dim <- list(Dimensions[["sps50"]], Dimensions[["Time"]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DATT <- Data  ## save to ensure that attributes are preserved
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## variables to add to the netCDF file:
\end_layout

\begin_layout Plain Layout

VarNew <- c('AKY', 'WIY', 'AK_GP', 'SS_GP', 'WIG', 'WDG', 'WSG', 'TASG',
 'UXG', 'VYG', 'ROC')
\end_layout

\begin_layout Plain Layout

VarOld <- c('AKRD', 'WIC', 'AKRD', 'SSRD', 'WIC', 'WDC', 'WSC', 'TASX',
 'UXC', 'VYC', 'GGVSPD') 
\end_layout

\begin_layout Plain Layout

VarUnits <- c('degrees', 'm/s', 'degrees', 'degrees', 'm/s', 'm/s', 'm/s',
 'm/s', 'm/s', 'm/s', 'm/s')
\end_layout

\begin_layout Plain Layout

VarStdName <- c('angle-of-attack, CF', 'vertical wind, CF', 'angle-of-attack,
 GP', 'sideslip angle, GP', 'vertical wind, GP', 'wind direction, GP', 'wind
 speed, GP', 'true airspeed, GP', 'wind longitudinal component, GP', 'wind
 lateral component, GP', 'rate of climb')
\end_layout

\begin_layout Plain Layout

VarLongName <- c('angle of attack, complementary-filter',
\end_layout

\begin_layout Plain Layout

                 'vertical wind using comp-filter angle of attack',
\end_layout

\begin_layout Plain Layout

                 'angle of attack from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'sideslip angle from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'vertical wind from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind direction from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind speed from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'true airspeed from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind, longitudinal component, gustpod',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind, lateral component, gustpod',
\end_layout

\begin_layout Plain Layout

                 'rate of climb of the aircraft from pressure')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## create the new variables
\end_layout

\begin_layout Plain Layout

varCDF <- list ()
\end_layout

\begin_layout Plain Layout

for (i in 1:length(VarNew)) {
\end_layout

\begin_layout Plain Layout

  print (sprintf ('new-netcdf %d%% done', as.integer(100*(i-1)/length(VarNew))))
\end_layout

\begin_layout Plain Layout

  varCDF[[i]] <- ncvar_def (VarNew[i],  
\end_layout

\begin_layout Plain Layout

                            units=VarUnits[i], 
\end_layout

\begin_layout Plain Layout

                            dim=Dim, 
\end_layout

\begin_layout Plain Layout

                            missval=as.single(-32767.), prec='float', 
\end_layout

\begin_layout Plain Layout

                            longname=VarLongName[i])
\end_layout

\begin_layout Plain Layout

  if (i == 1) {
\end_layout

\begin_layout Plain Layout

    newfile <- ncvar_add (netCDFfile, varCDF[[i]])
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    newfile <- ncvar_add (newfile, varCDF[[i]])
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ATV <- ncatt_get (netCDFfile, VarOld[i])
\end_layout

\begin_layout Plain Layout

  copy_attributes (ATV, VarNew[i], newfile)
\end_layout

\begin_layout Plain Layout

  ncatt_put (newfile, VarNew[i], attname="standard_name", 
\end_layout

\begin_layout Plain Layout

             attval=VarStdName[i])
\end_layout

\begin_layout Plain Layout

  if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

    ncvar_put (newfile, varCDF[[i]], Data[, VarNew[i]])
\end_layout

\begin_layout Plain Layout

  } else if (Rate == 25) {
\end_layout

\begin_layout Plain Layout

    ncvar_put (newfile, varCDF[[i]], Data[, VarNew[i]], count=c(25, nrow(Data)/2
5))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nc_close (newfile)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The transformations from the gust-pod reference frame to the aircraft reference
 frame are involved and likely to need careful check-out when implemented,
 so instead the recommended initial approach is to use a separate processor
 to add these variables to the netCDF files.
 This processor is included in the QAtools shiny app, under the 
\begin_inset Quotes eld
\end_inset

Special
\begin_inset Quotes erd
\end_inset

 tab, as an option in the 
\begin_inset Quotes eld
\end_inset

Options for Wind
\begin_inset Quotes erd
\end_inset

 tab.
 That tab also supports addition of the complementary-filter-based angle
 of attack and associated vertical wind as well as the addition of a high-pass-f
iltered version of the vertical wind.
 A new file with the suffix 
\begin_inset Quotes eld
\end_inset

Y
\begin_inset Quotes erd
\end_inset

 added to the name (e.g., SOCRATESrf01Y.nc) is created using a copy of the
 original, and these variables are added to that file:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
New Variable
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Descriptiion
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Reference
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AKY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
angle-of-attack, complementary-filter algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eqns._(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-fast"

\end_inset

), (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-slow"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WIY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertical wind, based on AKCF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Summary"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AK_GP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
angle-of-attack from the gust pod, in the a-frame
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SS_GP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sideslip angle from the gust pod, in the a-frame
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WIG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertical wind calculated using AK_GP and SS_GP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WDG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind direction using AK_GP and SS_GP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WSG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind direction using AK_GP and SS_GP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TASG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
airspeed calculate from the gust-pod
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UXG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind from the gust pod, longitudinal component
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VYG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind from the gust pod, lateral (starboard) component
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ROC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rate of climb of the aircraft, using hydrostatic equation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Reproducibility
\end_layout

\begin_layout Standard
This document is constructed in ways that support duplication of the study.
 The code that generates the plots and implements the processing algorithm
 is incorporated into the same file that generated this document via 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

, using principles and techniques described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a"

\end_inset

 as implemented in the R package 'knitr' (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014b"

\end_inset

).
 The program, 'AddingGustPodSocrates.Rnw', is archived on 'GitHub' in the
 directory at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/WilliamCooper/GustPodProcessing.git"

\end_inset

.
 There is some supplemental material in that directory, including the workflow
 document, the bibliography and some code segments saved in the 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

 subdirectory.
 This full directory should be downloaded in order to run the program.
 The calculations use the programming language R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"

\end_inset

) and were run within RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"

\end_inset

), so this is the most straightforward way to replicate the calculations
 and the generation of this document.
\end_layout

\begin_layout Standard
A package named Ranadu, containing auxillary functions, is used extensively
 in the R code.
 It is available on GitHub as 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/WilliamCooper/Ranadu.git"

\end_inset

.
 The version used for calculations in this technical note is included in
 the 'zip' archive listed below.
\end_layout

\begin_layout Standard
The original files containing the data as produced by the NCAR Earth Observing
 Laboratory, Research Aviation Facility, were in netCDF format (cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "http://www.unidata.ucar.edu/software/netcdf/"

\end_inset

), but particularly for SOCRATES the files used are preliminary data not
 yet released for general use.
 The officially released data files should be used once they are available.
 The subset data frames constructed from those preliminary netCDF files
 are saved and can be provided by the author, if or when that is consistent
 with the project data policies.
 The code in the GitHub archive has appropriate 'load' commands to read
 these data files from a subdirectory named 'Data' (/Data or ~/Data or /home/Dat
a) but this is not part of the GitHub repository because it is too large
 to be appropriate there.
 To reproduce this research, those data files have to be transferred separately
 from the NCAR HPSS to the 'Data' directory.
 Some use has been made of attributes assigned to the data.frames and the
 variables in those data.frames.
 All the attributes from the original netCDF files have been transferred,
 so there is a record of how the original data were processed, for example
 recording calibration coefficients and processing chains for the variables.
 Once the data.frames are loaded into R, these attributes can be viewed and
 provide additional documentation of what data were used.
 Key information like the processing date, the program version that produced
 the archive, and the selection of primary variables for various measurements
 thus is preserved.
\end_layout

\begin_layout Standard
(See the related list of project components on the next page.)
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AddingGustPodSocrates
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "AddingGustPodSocrates.zip"
target "https://github.com/WilliamCooper/GustPod/blob/master/AddingGustPodSocrates.zip"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "AddingGustPodSocrates.Rnw"
target "https://github.com/WilliamCooper/GustPod/blob/master/AddingGustPodSocrates.Rnw"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Special Data Files:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AKRDdata.Rdata
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow Document:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "WorkflowAddingGustPodSocrates.pdf"
target "https://github.com/WilliamCooper/GustPod/blob/master/WorkflowAddingGustPodSocrates.pdf"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/WilliamCooper/GustPod/AddingGustPodSocrates.git"
target "https://github.com/WilliamCooper/GustPod/AddingGustPodSocrates.git"

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
attachm{
\end_layout

\end_inset

AddingGustPodSocrates.Rnw
\begin_inset Newline newline
\end_inset

AddingGustPodSocrates.pdf
\begin_inset Newline newline
\end_inset

WorkflowAddingGustPodSocrates.pdf
\begin_inset Newline newline
\end_inset

WAC.bib
\begin_inset Newline newline
\end_inset

chunks/*
\begin_inset Newline newline
\end_inset

SessionInfo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{References}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bibliography"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "WAC"
options "plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
centerline{-- Blank Page, End of this Technical Report --}
\end_layout

\begin_layout Plain Layout


\backslash
vfill
\backslash
eject
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
addcontentsline{toc}{section}{End}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<make-zip-archive, INCLUDE=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

system (sprintf("zip AddingGustPodSocrates.zip AddingGustPodSocrates.Rnw AddingGus
tPodSocrates.pdf WorkflowAddingGustPodSocrates.pdf WAC.bib ./chunks/* SessionInfo"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip0.5truein 
\backslash
centerline{
\backslash
textcolor{blue}{---- END ----}}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
this is just a closing line to note end of the memo
\end_layout

\end_inset


\end_layout

\end_body
\end_document
